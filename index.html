<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0a0e27">
    <title>LastWar: Cyber Survival - ULTIMATE EDITION ✨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed;
            font-family: 'Courier New', monospace;
            background: linear-gradient(180deg, #0a0e27 0%, #1a0a2e 100%);
            color: #00ffff;
            overscroll-behavior: none;
        }

        body {
            padding-top: env(safe-area-inset-top);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
            padding-bottom: env(safe-area-inset-bottom);
        }

        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
            background: #0d0d0d;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.5), 0 0 100px rgba(255, 0, 110, 0.3);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 14, 39, 0.98);
            display: none;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            z-index: 100;
            padding: clamp(15px, 4vw, 20px);
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
        }

        .screen.active {
            display: flex;
        }

        h1 {
            font-size: clamp(28px, 7vw, 48px);
            text-shadow: 0 0 20px #00ffff, 0 0 40px #ff006e;
            margin-bottom: clamp(20px, 4vw, 30px);
            letter-spacing: clamp(2px, 0.5vw, 4px);
            animation: glitch 2s infinite;
            text-align: center;
            line-height: 1.2;
        }

        @keyframes glitch {
            0%, 100% { text-shadow: 0 0 20px #00ffff, 0 0 40px #ff006e; }
            50% { text-shadow: 2px 0 20px #ff006e, -2px 0 40px #00ffff; }
        }

        .button {
            background: linear-gradient(135deg, #00ffff 0%, #ff006e 100%);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: clamp(12px, 3vw, 15px) clamp(30px, 6vw, 40px);
            margin: clamp(8px, 2vw, 10px);
            font-size: clamp(16px, 4vw, 20px);
            cursor: pointer;
            border-radius: clamp(6px, 1.5vw, 8px);
            text-shadow: 0 0 10px #000;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5), inset 0 0 10px rgba(255, 255, 255, 0.2);
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            letter-spacing: clamp(1px, 0.3vw, 2px);
            touch-action: manipulation;
            min-height: 48px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .button:active {
            transform: scale(0.95);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
        }

        .level-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(clamp(60px, 15vw, 70px), 1fr));
            gap: clamp(8px, 2vw, 10px);
            margin: clamp(15px, 3vw, 30px) 0;
            width: 100%;
            max-width: 600px;
            max-height: 50vh;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 10px;
            -webkit-overflow-scrolling: touch;
        }

        .level-button {
            aspect-ratio: 1;
            min-height: 60px;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #00ffff;
            color: #00ffff;
            font-size: clamp(20px, 5vw, 24px);
            cursor: pointer;
            border-radius: clamp(6px, 1.5vw, 8px);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            transition: all 0.3s;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            position: relative;
            touch-action: manipulation;
        }

        .level-button:active:not(.locked) {
            background: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
            transform: scale(0.95);
        }

        .level-button.locked {
            background: rgba(100, 100, 100, 0.2);
            border-color: #555;
            color: #555;
            cursor: not-allowed;
        }

        .level-button.boss {
            border-color: #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            font-size: clamp(24px, 6vw, 32px);
        }

        .level-button.current {
            animation: pulse 1s infinite;
            background: rgba(255, 215, 0, 0.3);
            border-color: #ffd700;
            color: #ffd700;
        }

        .stars {
            font-size: clamp(8px, 2vw, 10px);
            position: absolute;
            bottom: 2px;
            left: 50%;
            transform: translateX(-50%);
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
            50% { box-shadow: 0 0 30px rgba(255, 215, 0, 1); }
        }

        .upgrade-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: clamp(10px, 2.5vw, 15px);
            width: 100%;
            max-width: 700px;
            margin: clamp(15px, 3vw, 20px) 0;
            padding: 0 10px;
        }

        .upgrade-card, .ship-card {
            background: rgba(10, 14, 39, 0.8);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: clamp(8px, 2vw, 10px);
            padding: clamp(12px, 3vw, 15px);
            text-align: center;
            box-shadow: 0 0 20px rgba(255, 0, 110, 0.2);
            transition: all 0.3s;
            touch-action: manipulation;
        }

        .ship-card.selected {
            border: 3px solid #ffd700;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
        }

        .ship-card.legendary {
            border: 2px solid #ff00ff;
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.1), rgba(138, 43, 226, 0.1));
            animation: legendaryGlow 2s infinite;
        }

        @keyframes legendaryGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 0, 255, 0.5); }
            50% { box-shadow: 0 0 40px rgba(255, 0, 255, 0.8); }
        }

        .upgrade-card h3, .ship-card h3 {
            font-size: clamp(14px, 3.5vw, 16px);
            margin-bottom: clamp(8px, 2vw, 10px);
            color: #00ffff;
        }

        .upgrade-icon, .ship-icon {
            font-size: clamp(36px, 8vw, 40px);
            margin: clamp(8px, 2vw, 10px) 0;
        }

        .upgrade-level {
            font-size: clamp(16px, 4vw, 18px);
            color: #ffd700;
            margin: clamp(4px, 1vw, 5px) 0;
        }

        .upgrade-cost, .ship-cost {
            font-size: clamp(14px, 3.5vw, 16px);
            color: #ff006e;
            margin: clamp(4px, 1vw, 5px) 0;
        }

        .upgrade-card .button, .ship-card .button {
            padding: clamp(8px, 2vw, 10px) clamp(16px, 4vw, 20px);
            font-size: clamp(12px, 3vw, 14px);
            margin-top: clamp(8px, 2vw, 10px);
            width: 100%;
        }

        .upgrade-card .button:disabled, .ship-card .button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .credits-display {
            position: fixed;
            top: calc(20px + env(safe-area-inset-top));
            right: clamp(15px, 4vw, 20px);
            font-size: clamp(18px, 4.5vw, 24px);
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: clamp(8px, 2vw, 10px) clamp(12px, 3vw, 15px);
            border-radius: clamp(6px, 1.5vw, 8px);
            border: 1px solid rgba(255, 215, 0, 0.3);
        }

        .modal {
            background: rgba(10, 14, 39, 0.95);
            border: 2px solid #00ffff;
            border-radius: clamp(12px, 3vw, 15px);
            padding: clamp(20px, 5vw, 30px);
            max-width: min(500px, 90vw);
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.5);
            text-align: center;
            animation: modalSlideIn 0.5s ease-out;
        }
        
        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50px) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        /* 🎬 EPIC Boss Victory Modal Styling */
        .modal.boss-victory {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2) 0%, rgba(10, 14, 39, 0.95) 40%, rgba(10, 14, 39, 0.95) 60%, rgba(255, 0, 110, 0.2) 100%);
            border: 4px solid #ffd700;
            box-shadow: 
                0 0 50px rgba(255, 215, 0, 1),
                0 0 100px rgba(255, 215, 0, 0.6),
                inset 0 0 80px rgba(255, 215, 0, 0.15);
            animation: bossModalEntrance 0.8s cubic-bezier(0.34, 1.56, 0.64, 1), bossModalGlow 2s ease-in-out infinite;
            position: relative;
            overflow: visible;
        }
        
        .modal.boss-victory::before {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            background: linear-gradient(45deg, #ffd700, #ff6600, #ffd700, #ff00ff, #ffd700);
            background-size: 400% 400%;
            border-radius: clamp(12px, 3vw, 15px);
            z-index: -1;
            animation: rainbowBorder 3s linear infinite;
            opacity: 0.6;
        }
        
        @keyframes rainbowBorder {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        @keyframes bossModalEntrance {
            0% {
                opacity: 0;
                transform: translateY(-100px) scale(0.3);
            }
            50% {
                transform: translateY(20px) scale(1.1);
            }
            70% {
                transform: translateY(-10px) scale(0.95);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        @keyframes bossModalGlow {
            0%, 100% {
                box-shadow: 
                    0 0 50px rgba(255, 215, 0, 1),
                    0 0 100px rgba(255, 215, 0, 0.6),
                    inset 0 0 80px rgba(255, 215, 0, 0.15);
            }
            50% {
                box-shadow: 
                    0 0 70px rgba(255, 215, 0, 1),
                    0 0 140px rgba(255, 215, 0, 0.8),
                    inset 0 0 100px rgba(255, 215, 0, 0.25);
            }
        }
        
        .modal.boss-victory h2 {
            color: #ffd700 !important;
            font-size: clamp(32px, 8vw, 48px) !important;
            text-shadow: 
                0 0 10px #ffd700,
                0 0 20px #ffd700,
                0 0 30px #ff6600,
                2px 2px 0 rgba(255, 0, 0, 0.5),
                -2px -2px 0 rgba(0, 255, 255, 0.5);
            animation: titlePulse 1.5s ease-in-out infinite;
            letter-spacing: 2px;
        }
        
        @keyframes titlePulse {
            0%, 100% {
                transform: scale(1);
                text-shadow: 
                    0 0 10px #ffd700,
                    0 0 20px #ffd700,
                    0 0 30px #ff6600,
                    2px 2px 0 rgba(255, 0, 0, 0.5),
                    -2px -2px 0 rgba(0, 255, 255, 0.5);
            }
            50% {
                transform: scale(1.05);
                text-shadow: 
                    0 0 20px #ffd700,
                    0 0 40px #ffd700,
                    0 0 60px #ff6600,
                    3px 3px 0 rgba(255, 0, 0, 0.7),
                    -3px -3px 0 rgba(0, 255, 255, 0.7);
            }
        }

        .modal h2 {
            font-size: clamp(24px, 6vw, 32px);
            margin-bottom: clamp(15px, 3vw, 20px);
            color: #00ffff;
        }

        .modal p {
            font-size: clamp(14px, 3.5vw, 18px);
            margin: clamp(8px, 2vw, 10px) 0;
            color: #fff;
        }

        .stats {
            margin: clamp(15px, 3vw, 20px) 0;
            color: #ffd700;
        }
        
        /* 🎬 Boss Victory Stats Animation */
        .boss-victory .stats p {
            animation: statsPop 0.6s ease-out backwards;
            color: #ffd700 !important;
            text-shadow: 0 0 10px #ffd700;
            font-weight: bold;
        }
        
        .boss-victory .stats p:nth-child(1) { animation-delay: 0.1s; }
        .boss-victory .stats p:nth-child(2) { animation-delay: 0.2s; }
        .boss-victory .stats p:nth-child(3) { animation-delay: 0.3s; }
        .boss-victory .stats p:nth-child(4) { animation-delay: 0.4s; }
        .boss-victory .stats p:nth-child(5) { animation-delay: 0.5s; }
        
        @keyframes statsPop {
            0% {
                opacity: 0;
                transform: translateX(-50px) scale(0.5);
            }
            70% {
                transform: translateX(10px) scale(1.1);
            }
            100% {
                opacity: 1;
                transform: translateX(0) scale(1);
            }
        }
        
        .boss-victory .stats span {
            display: inline-block;
            animation: numberBounce 1s ease-in-out infinite;
        }
        
        @keyframes numberBounce {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.15);
            }
        }
        
        /* 🎬 Boss Victory Buttons */
        .boss-victory .button {
            background: linear-gradient(135deg, #ffd700 0%, #ff6600 50%, #ffd700 100%);
            background-size: 200% 200%;
            animation: buttonShimmer 2s ease-in-out infinite;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            font-size: clamp(18px, 4.5vw, 22px) !important;
        }
        
        @keyframes buttonShimmer {
            0%, 100% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
        }
        
        .boss-victory .button:active {
            transform: scale(0.95);
            box-shadow: 0 0 30px rgba(255, 215, 0, 1);
        }
        
        /* 🎬 Boss Victory Stars */
        .boss-victory #levelStars {
            font-size: clamp(32px, 8vw, 48px) !important;
            animation: starsSparkle 1s ease-in-out infinite;
            display: inline-block;
        }
        
        @keyframes starsSparkle {
            0%, 100% {
                transform: scale(1) rotate(0deg);
                filter: drop-shadow(0 0 5px #ffd700);
            }
            25% {
                transform: scale(1.2) rotate(-5deg);
                filter: drop-shadow(0 0 15px #ffd700);
            }
            75% {
                transform: scale(1.2) rotate(5deg);
                filter: drop-shadow(0 0 15px #ffd700);
            }
        }

        .achievements {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: clamp(8px, 2vw, 10px);
            margin: clamp(15px, 3vw, 20px) 0;
        }

        .achievement {
            font-size: clamp(28px, 6vw, 32px);
            filter: grayscale(100%);
            opacity: 0.3;
            transition: all 0.3s;
        }

        .achievement.unlocked {
            filter: grayscale(0%);
            opacity: 1;
            animation: achievementPop 0.5s ease;
        }

        @keyframes achievementPop {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.3); }
        }

        .scanline {
            position: absolute;
            width: 100%;
            height: 2px;
            background: rgba(0, 255, 255, 0.5);
            animation: scanline 4s linear infinite;
            pointer-events: none;
        }

        @keyframes scanline {
            0% { top: -100%; }
            100% { top: 100%; }
        }

        .intro-card {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 14, 39, 0.98);
            border: 3px solid #00ffff;
            border-radius: clamp(15px, 4vw, 20px);
            padding: clamp(30px, 7vw, 40px);
            text-align: center;
            z-index: 200;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.8);
            animation: introSlide 0.5s ease;
            max-width: 90vw;
        }

        @keyframes introSlide {
            0% { transform: translate(-50%, -50%) scale(0); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        .warning-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(32px, 8vw, 48px);
            color: #ff0000;
            text-shadow: 0 0 30px #ff0000;
            font-weight: bold;
            animation: warningPulse 0.5s ease infinite;
            z-index: 150;
            text-align: center;
            max-width: 90vw;
        }

        @keyframes warningPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.7; }
        }

        .ship-preview {
            margin: clamp(15px, 3vw, 20px) 0;
            font-size: clamp(12px, 3vw, 14px);
            color: #888;
        }

        .tab-container {
            display: flex;
            gap: clamp(8px, 2vw, 10px);
            margin: clamp(15px, 3vw, 20px) 0;
            width: 100%;
            max-width: 600px;
            flex-wrap: wrap;
        }

        .tab {
            flex: 1;
            min-width: 120px;
            padding: clamp(10px, 2.5vw, 12px) clamp(15px, 4vw, 20px);
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #00ffff;
            border-radius: clamp(6px, 1.5vw, 8px);
            cursor: pointer;
            transition: all 0.3s;
            font-size: clamp(14px, 3.5vw, 16px);
            text-align: center;
            touch-action: manipulation;
        }

        .tab:active {
            transform: scale(0.95);
        }

        .tab.active {
            background: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
        }

        #mainMenu {
            justify-content: center;
        }

        #mainMenu p {
            font-size: clamp(12px, 3vw, 14px);
            line-height: 1.6;
            max-width: 90vw;
        }

        #levelSelect {
            padding-bottom: calc(80px + env(safe-area-inset-bottom));
        }

        .fixed-bottom-buttons {
            position: fixed;
            bottom: env(safe-area-inset-bottom);
            left: 0;
            right: 0;
            padding: clamp(10px, 2.5vw, 15px);
            background: rgba(10, 14, 39, 0.95);
            border-top: 2px solid rgba(0, 255, 255, 0.3);
            display: flex;
            gap: clamp(8px, 2vw, 10px);
            z-index: 101;
        }

        .fixed-bottom-buttons .button {
            flex: 1;
            margin: 0;
        }

        @media (orientation: landscape) and (max-height: 500px) {
            h1 {
                font-size: clamp(20px, 5vw, 32px);
                margin-bottom: 15px;
            }

            .level-grid {
                max-height: 60vh;
            }

            .modal {
                padding: 15px;
                max-height: 80vh;
                overflow-y: auto;
            }
        }

        @media (max-width: 360px) {
            .level-grid {
                grid-template-columns: repeat(3, 1fr);
            }

            .upgrade-container {
                grid-template-columns: 1fr;
            }
        }

        @media (min-width: 768px) {
            .level-grid {
                grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
                max-width: 700px;
            }

            .upgrade-container {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        body {
            position: fixed;
            width: 100%;
        }

        .ship-ability-badge {
            font-size: clamp(10px, 2.5vw, 11px);
            background: rgba(255, 0, 255, 0.3);
            border: 1px solid #ff00ff;
            border-radius: 4px;
            padding: 2px 6px;
            margin: 4px auto;
            display: inline-block;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div class="scanline"></div>
        
        <!-- Main Menu -->
        <div id="mainMenu" class="screen active">
            <h1>LASTWAR<br>CYBER SURVIVAL</h1>
            <p style="color: #ff006e; font-size: clamp(16px, 4vw, 20px); margin-bottom: 10px;">🚀 MEGA ULTRA EDITION 🚀</p>
            <p style="color: #00ffff; font-size: clamp(12px, 3vw, 14px); margin-bottom: 20px; opacity: 0.8;">Version 0.1.3</p>
            <p style="color: #ff00ff; font-size: clamp(14px, 3.5vw, 18px); margin-bottom: 10px;">⚡ PHASE 1: ATMOSPHERE 🛡️ + MUSIC 🎵 ⚡</p>
            <button class="button" onclick="game.showLevelSelect()">▶ START</button>
            <button class="button" onclick="game.toggleSound()">🔊 SOUND: <span id="soundStatus">ON</span></button>
            <button class="button" onclick="game.showAchievements()">🏆 ACHIEVEMENTS</button>
            <p style="margin-top: 30px; color: #888; font-size: clamp(11px, 2.8vw, 14px);">
                🎮 Use ARROW KEYS or A/D to switch lanes<br>
                📱 Swipe LEFT/RIGHT on mobile<br>
                🎯 Dodge red projectiles!<br>
                ⚡ Collect power-ups for special weapons!<br>
                🔥 Build 5x combo for SUPER MISSILE!<br>
                👑 Face epic ARENA boss battles!<br>
                <span style="color: #ff00ff;">✨ NEW: 3 LEGENDARY SHIPS WITH ABILITIES!</span><br>
                <span style="color: #ffd700;">☠️ NEW: BOSS ARENA LOCKDOWN SYSTEM!</span><br>
                <span style="color: #00ff00;">🛡️ NEW: 8 DYNAMIC WEATHER SYSTEMS!</span><br>
                <span style="color: #00ffff;">🎨 NEW: PARALLAX BACKGROUNDS & FOG!</span><br>
                <span style="color: #ff00ff;">🎵 NEW: DYNAMIC LAYERED MUSIC SYSTEM!</span>
            </p>
        </div>

        <!-- Level Select -->
        <div id="levelSelect" class="screen">
            <h1>COMMAND CENTER</h1>
            <div class="credits-display">💎 <span id="creditsDisplay">0</span></div>
            
            <div class="tab-container">
                <div class="tab active" onclick="game.showTab('levels')">LEVELS</div>
                <div class="tab" onclick="game.showTab('ships')">SHIPS</div>
                <div class="tab" onclick="game.showTab('upgrades')">UPGRADES</div>
            </div>
            
            <div id="levelsTab">
                <div class="level-grid" id="levelGrid"></div>
                <div class="achievements" id="achievementsMini"></div>
            </div>
            
            <div id="shipsTab" style="display: none;">
                <p style="color: #00ffff; margin: 20px 0; font-size: clamp(14px, 3.5vw, 16px);">Select your starship:</p>
                <div class="upgrade-container" id="shipContainer"></div>
            </div>
            
            <div id="upgradesTab" style="display: none;">
                <p style="color: #00ffff; margin: 20px 0; font-size: clamp(14px, 3.5vw, 16px);">Upgrade your combat systems:</p>
                <div class="upgrade-container" id="upgradeContainer"></div>
            </div>
            
            <div class="fixed-bottom-buttons">
                <button class="button" onclick="game.startSelectedLevel()">🚀 LAUNCH MISSION</button>
                <button class="button" onclick="game.showMainMenu()">⬅ BACK</button>
            </div>
        </div>

        <!-- Achievements Screen -->
        <div id="achievementsScreen" class="screen">
            <h1>ACHIEVEMENTS</h1>
            <div style="max-width: 600px; width: 100%; text-align: left; overflow-y: auto;">
                <div id="achievementsList"></div>
            </div>
            <div class="fixed-bottom-buttons">
                <button class="button" onclick="game.showMainMenu()">⬅ BACK</button>
            </div>
        </div>

        <!-- Game Over -->
        <div id="gameOver" class="screen">
            <div class="modal">
                <h2>MISSION FAILED ❌</h2>
                <div class="stats">
                    <p>Credits Earned: <span id="earnedCredits">0</span> 💎</p>
                    <p>Distance: <span id="distanceTraveled">0</span>m</p>
                    <p>Max Combo: <span id="maxCombo">0</span>x</p>
                    <p>Stars Earned: <span id="starsEarned">0</span> ⭐</p>
                </div>
                <button class="button" onclick="game.retry()">🔄 RETRY</button>
                <button class="button" onclick="game.showLevelSelect()">⬆️ UPGRADE</button>
                <button class="button" onclick="game.showMainMenu()">🏠 EXIT</button>
            </div>
        </div>

        <!-- Level Complete -->
        <div id="levelComplete" class="screen">
            <div class="modal">
                <h2>MISSION COMPLETE! ✓</h2>
                <div class="stats">
                    <p>Distance: <span id="completeDistance">0</span>m</p>
                    <p>Enemies: <span id="enemiesKilled">0</span></p>
                    <p>Max Combo: <span id="completeMaxCombo">0</span>x</p>
                    <p>Completion: +<span id="completionBonus">0</span> 💎</p>
                    <p style="border-top: 1px solid #00ffff; padding-top: 10px; margin-top: 10px;">
                        <strong>TOTAL: +<span id="totalEarned">0</span> 💎</strong>
                    </p>
                    <p style="font-size: clamp(24px, 6vw, 32px); margin-top: 10px;">
                        <span id="levelStars"></span>
                    </p>
                </div>
                <div id="newAchievements"></div>
                <button class="button" onclick="game.nextLevel()">➡ NEXT LEVEL</button>
                <button class="button" onclick="game.showLevelSelect()">🏠 COMMAND CENTER</button>
            </div>
        </div>

        <!-- Pause Menu -->
        <div id="pauseMenu" class="screen">
            <div class="modal">
                <h2>PAUSED</h2>
                <button class="button" onclick="game.resume()">▶ RESUME</button>
                <button class="button" onclick="game.restartLevel()">🔄 RESTART</button>
                <button class="button" onclick="game.exitToMenu()">🏠 EXIT TO MENU</button>
                <button class="button" onclick="game.toggleSound()">🔊 SOUND</button>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // RESPONSIVE CANVAS MANAGER
        // ========================================

        // ═══════════════════════════════════════════════════════════════════════════════
        // 🎮 MODULE: UTILITY SYSTEMS
        // ═══════════════════════════════════════════════════════════════════════════════
        // PURPOSE: Canvas management, responsive scaling
        // SAFE TO MODIFY: Rarely needed unless changing screen dimensions
        // ═══════════════════════════════════════════════════════════════════════════════

        class ResponsiveCanvas {
            constructor(canvas, baseWidth = 800, baseHeight = 600) {
                this.canvas = canvas;
                this.baseWidth = baseWidth;
                this.baseHeight = baseHeight;
                this.scale = 1;
                this.offsetX = 0;
                this.offsetY = 0;
                
                this.resize();
                window.addEventListener('resize', () => this.resize());
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => this.resize(), 100);
                });
            }
            
            resize() {
                const container = this.canvas.parentElement;
                const containerWidth = container.clientWidth;
                const containerHeight = container.clientHeight;
                
                const scaleX = containerWidth / this.baseWidth;
                const scaleY = containerHeight / this.baseHeight;
                this.scale = Math.min(scaleX, scaleY);
                
                this.canvas.width = this.baseWidth;
                this.canvas.height = this.baseHeight;
                
                this.offsetX = (containerWidth - (this.baseWidth * this.scale)) / 2;
                this.offsetY = (containerHeight - (this.baseHeight * this.scale)) / 2;
            }
            
            getMousePos(clientX, clientY) {
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: (clientX - rect.left) * (this.baseWidth / rect.width),
                    y: (clientY - rect.top) * (this.baseHeight / rect.height)
                };
            }
        }

        // ========================================
        // ENHANCED AUDIO MANAGER WITH DYNAMIC MUSIC
        // ========================================
        // ========================================
        // 🎵 ULTIMATE AUDIO ENGINE with ENHANCED MUSIC SYSTEM
        // ========================================

        // ═══════════════════════════════════════════════════════════════════════════════
        // 🎵 MODULE: AUDIO SYSTEM
        // ═══════════════════════════════════════════════════════════════════════════════
        // PURPOSE: Dynamic music, sound effects, audio management
        // SAFE TO MODIFY: Sound volumes, music themes (advanced users)
        // DO NOT REMOVE: Entire system must stay intact
        // ═══════════════════════════════════════════════════════════════════════════════

        class AudioManager {
            constructor() {
                this.enabled = true;
                this.audioContext = null;
                this.masterGain = null;
                this.musicGain = null;
                this.sfxGain = null;
                
                // 🎵 Music sequencer state
                this.isPlaying = false;
                this.bpm = 140;
                this.beatDuration = (60 / this.bpm) * 1000;
                this.step = 0;
                this.bar = 0;
                
                // Dynamic intensity
                this.combatIntensity = 0;
                this.targetIntensity = 0;
                this.bossBattle = false;
                
                // Current theme
                this.currentTheme = null;
                this.currentThemeIndex = 0;
                
                // Layer states
                this.layers = {
                    kick: false,
                    snare: false,
                    hihat: false,
                    bass: false,
                    arp: false,
                    lead: false,
                    pad: false
                };
                
                // Sequencer timer
                this.sequencerInterval = null;
                
                // 🎙️ Track combo tier to avoid repetition
                this.lastComboTier = 0;
                
                // Theme definitions - matched to game levels
                this.themes = [
                    {
                        name: 'Cyber Neon',
                        key: 'A',
                        scale: [220, 246.94, 261.63, 293.66, 329.63, 349.23, 392],
                        chords: [
                            [220, 261.63, 329.63],
                            [196, 246.94, 293.66],
                            [261.63, 329.63, 392],
                            [196, 246.94, 293.66]
                        ],
                        bassPattern: [0, 0, 2, 0, 1, 1, 3, 1],
                        arpPattern: [0, 2, 4, 2, 1, 3, 5, 3],
                        leadMelody: [0, 2, 4, 3, 2, 4, 6, 4, 3, 2, 1, 0, 2, 4, 2, 0],
                        color: '#00ffff'
                    },
                    {
                        name: 'Toxic Green',
                        key: 'E',
                        scale: [164.81, 185, 196, 220, 246.94, 261.63, 293.66],
                        chords: [
                            [164.81, 196, 246.94],
                            [185, 220, 277.18],
                            [196, 246.94, 293.66],
                            [185, 220, 277.18]
                        ],
                        bassPattern: [0, 0, 1, 0, 2, 2, 1, 2],
                        arpPattern: [0, 2, 4, 2, 1, 3, 4, 2],
                        leadMelody: [0, 1, 2, 1, 3, 2, 4, 3, 2, 3, 4, 3, 5, 4, 3, 2],
                        color: '#00ff00'
                    },
                    {
                        name: 'Crimson Alert',
                        key: 'D',
                        scale: [146.83, 164.81, 174.61, 196, 220, 233.08, 261.63],
                        chords: [
                            [146.83, 174.61, 220],
                            [174.61, 207.65, 261.63],
                            [196, 233.08, 293.66],
                            [174.61, 207.65, 261.63]
                        ],
                        bassPattern: [0, 0, 2, 0, 1, 1, 3, 1],
                        arpPattern: [0, 2, 4, 2, 1, 3, 5, 3],
                        leadMelody: [6, 5, 4, 3, 4, 5, 6, 5, 4, 3, 2, 1, 2, 3, 4, 3],
                        color: '#ff0033'
                    },
                    {
                        name: 'Golden Sunset',
                        key: 'G',
                        scale: [196, 220, 233.08, 261.63, 293.66, 311.13, 349.23],
                        chords: [
                            [196, 246.94, 293.66],
                            [329.63, 392, 493.88],
                            [261.63, 329.63, 392],
                            [293.66, 369.99, 440]
                        ],
                        bassPattern: [0, 0, 1, 0, 2, 2, 3, 2],
                        arpPattern: [0, 2, 4, 2, 1, 3, 4, 2],
                        leadMelody: [0, 2, 4, 2, 1, 3, 5, 3, 4, 2, 3, 1, 2, 0, 1, 0],
                        color: '#ffd700'
                    },
                    {
                        name: 'Deep Purple',
                        key: 'C',
                        scale: [130.81, 146.83, 155.56, 174.61, 196, 207.65, 233.08],
                        chords: [
                            [130.81, 155.56, 196],
                            [146.83, 174.61, 220],
                            [174.61, 207.65, 261.63],
                            [146.83, 174.61, 220]
                        ],
                        bassPattern: [0, 0, 2, 0, 1, 1, 3, 1],
                        arpPattern: [0, 2, 4, 2, 1, 3, 5, 3],
                        leadMelody: [0, 2, 3, 2, 4, 3, 5, 4, 3, 2, 1, 2, 3, 2, 1, 0],
                        color: '#9d00ff'
                    },
                    {
                        name: 'Ice Blue',
                        key: 'F',
                        scale: [174.61, 196, 207.65, 233.08, 261.63, 277.18, 311.13],
                        chords: [
                            [174.61, 207.65, 261.63],
                            [196, 233.08, 293.66],
                            [233.08, 277.18, 349.23],
                            [196, 233.08, 293.66]
                        ],
                        bassPattern: [0, 0, 1, 0, 2, 2, 1, 2],
                        arpPattern: [0, 2, 4, 2, 1, 3, 4, 2],
                        leadMelody: [0, 1, 3, 2, 4, 3, 5, 4, 3, 4, 2, 3, 1, 2, 0, 1],
                        color: '#00d4ff'
                    },
                    {
                        name: 'Hot Pink',
                        key: 'B',
                        scale: [246.94, 277.18, 293.66, 329.63, 369.99, 392, 440],
                        chords: [
                            [246.94, 293.66, 369.99],
                            [277.18, 329.63, 415.30],
                            [329.63, 392, 493.88],
                            [277.18, 329.63, 415.30]
                        ],
                        bassPattern: [0, 0, 2, 0, 1, 1, 3, 1],
                        arpPattern: [0, 2, 4, 2, 1, 3, 5, 3],
                        leadMelody: [0, 2, 4, 5, 4, 2, 3, 1, 2, 4, 3, 5, 4, 2, 1, 0],
                        color: '#ff1493'
                    },
                    {
                        name: 'Electric Yellow',
                        key: 'D',
                        scale: [293.66, 329.63, 349.23, 392, 440, 466.16, 523.25],
                        chords: [
                            [293.66, 349.23, 440],
                            [329.63, 392, 493.88],
                            [392, 466.16, 587.33],
                            [329.63, 392, 493.88]
                        ],
                        bassPattern: [0, 0, 1, 0, 2, 2, 1, 2],
                        arpPattern: [0, 2, 4, 2, 1, 3, 4, 2],
                        leadMelody: [0, 2, 3, 4, 5, 4, 3, 2, 4, 5, 6, 5, 4, 3, 2, 1],
                        color: '#ffff00'
                    }
                ];
                
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.audioContext = new AudioContext();
                    
                    // Master gain
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.gain.value = 0.7;
                    this.masterGain.connect(this.audioContext.destination);
                    
                    // Music gain
                    this.musicGain = this.audioContext.createGain();
                    this.musicGain.gain.value = 1.0;
                    this.musicGain.connect(this.masterGain);
                    
                    // SFX gain
                    this.sfxGain = this.audioContext.createGain();
                    this.sfxGain.gain.value = 0.4;
                    this.sfxGain.connect(this.masterGain);
                    
                    // 🎙️ Load voices for speech synthesis
                    if (window.speechSynthesis) {
                        window.speechSynthesis.getVoices();
                        window.speechSynthesis.onvoiceschanged = () => {
                            window.speechSynthesis.getVoices();
                        };
                    }
                } catch (e) {
                    console.warn('Web Audio API not supported');
                }
            }
            
            // ========================================
            // 🎵 MUSIC SYSTEM
            // ========================================
            
            startMusic(theme) {
                if (!this.enabled) return;

                // 🔊 FIX: Handle missing audio context
                if (!this.audioContext) {
                    console.warn('Audio context not initialized');
                    return;
                }

                this.stopMusic();

                this.currentTheme = theme;

                // Find matching theme index
                this.currentThemeIndex = this.themes.findIndex(t => t.name === theme.name) || 0;

                // 🔊 FIX: Resume audio context if suspended (browser autoplay policy)
                if (this.audioContext.state === 'suspended') {
                    this.audioContext.resume().then(() => {
                        console.log('🎵 Audio context resumed - music should play now');
                    }).catch(err => {
                        console.error('Failed to resume audio:', err);
                    });
                }

                this.isPlaying = true;
                this.step = 0;
                this.bar = 0;
                
                // Start the sequencer
                const stepDuration = this.beatDuration / 4;
                this.sequencerInterval = setInterval(() => {
                    this.processStep();
                    this.step = (this.step + 1) % 16;
                    if (this.step === 0) {
                        this.bar = (this.bar + 1) % 4;
                    }
                }, stepDuration);
            }
            
            stopMusic() {
                this.isPlaying = false;
                if (this.sequencerInterval) {
                    clearInterval(this.sequencerInterval);
                    this.sequencerInterval = null;
                }
                Object.keys(this.layers).forEach(key => {
                    this.layers[key] = false;
                });
            }
            
            processStep() {
                const theme = this.themes[this.currentThemeIndex];
                const time = this.audioContext.currentTime;
                
                // Clear previous layer states
                Object.keys(this.layers).forEach(key => this.layers[key] = false);
                
                // 🥁 DRUMS - intensity based
                if (this.combatIntensity > 0.1) {
                    // Kick drum - on beats 0, 4, 8, 12
                    if (this.step % 4 === 0) {
                        this.playKick(time);
                        this.layers.kick = true;
                    }
                    
                    // Snare - on beats 4, 12
                    if (this.step === 4 || this.step === 12) {
                        this.playSnare(time);
                        this.layers.snare = true;
                    }
                    
                    // Hi-hat - 8th notes when intensity > 0.3
                    if (this.combatIntensity > 0.3 && this.step % 2 === 0) {
                        this.playHiHat(time);
                        this.layers.hihat = true;
                    }
                    
                    // Fast hi-hats in boss battle (16th notes)
                    if (this.bossBattle) {
                        this.playHiHat(time, 0.5);
                        this.layers.hihat = true;
                    }
                }
                
                // 🎸 BASS - Active from low intensity
                if (this.combatIntensity > 0.2) {
                    const bassNoteIndex = theme.bassPattern[this.step % 8];
                    const bassChord = theme.chords[bassNoteIndex];
                    const bassFreq = bassChord[0];
                    
                    if (this.step % 4 === 0 || (this.combatIntensity > 0.5 && this.step % 2 === 0)) {
                        this.playBass(time, bassFreq);
                        this.layers.bass = true;
                    }
                }
                
                // 🎹 ARPEGGIATOR - Active from medium intensity
                if (this.combatIntensity > 0.4) {
                    const chordIndex = theme.bassPattern[Math.floor(this.step / 4)];
                    const chord = theme.chords[chordIndex];
                    const arpNoteIndex = theme.arpPattern[this.step % 8];
                    const arpFreq = chord[arpNoteIndex % chord.length];
                    
                    this.playArp(time, arpFreq);
                    this.layers.arp = true;
                }
                
                // 🎺 LEAD MELODY - Active from high intensity
                if (this.combatIntensity > 0.6) {
                    if (this.step % 4 === 0 || this.step % 4 === 2) {
                        const melodyIndex = (this.bar * 4 + Math.floor(this.step / 4)) % theme.leadMelody.length;
                        const scaleIndex = theme.leadMelody[melodyIndex];
                        const leadFreq = theme.scale[scaleIndex];
                        
                        this.playLead(time, leadFreq);
                        this.layers.lead = true;
                    }
                }
                
                // ðŸŒŠ PAD - Always playing softly
                if (this.step === 0 && this.combatIntensity > 0.1) {
                    const chordIndex = theme.bassPattern[0];
                    const chord = theme.chords[chordIndex];
                    this.playPad(time, chord);
                    this.layers.pad = true;
                }
            }
            
            // 🥁 KICK DRUM
            playKick(time) {
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(150, time);
                osc.frequency.exponentialRampToValueAtTime(50, time + 0.1);
                
                const volume = 0.8 * this.combatIntensity;
                gain.gain.setValueAtTime(volume, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.15);
                
                osc.connect(gain);
                gain.connect(this.musicGain);
                osc.start(time);
                osc.stop(time + 0.15);
            }
            
            // 🥁 SNARE
            playSnare(time) {
                const noise = this.audioContext.createBufferSource();
                const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 0.1, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                noise.buffer = buffer;
                
                const filter = this.audioContext.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 1000;
                
                const gain = this.audioContext.createGain();
                const volume = 0.4 * this.combatIntensity;
                gain.gain.setValueAtTime(volume, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
                
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.musicGain);
                noise.start(time);
                noise.stop(time + 0.1);
            }
            
            // 🥁 HI-HAT
            playHiHat(time, volumeMult = 1.0) {
                const noise = this.audioContext.createBufferSource();
                const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 0.05, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                noise.buffer = buffer;
                
                const filter = this.audioContext.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 7000;
                
                const gain = this.audioContext.createGain();
                const volume = 0.2 * this.combatIntensity * volumeMult;
                gain.gain.setValueAtTime(volume, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);
                
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.musicGain);
                noise.start(time);
                noise.stop(time + 0.05);
            }
            
            // 🎸 BASS
            playBass(time, freq) {
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                
                osc.type = 'sawtooth';
                osc.frequency.value = freq / 2;
                
                const filter = this.audioContext.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 200 + (this.combatIntensity * 300);
                
                const volume = 0.3 * Math.min(1, 0.5 + this.combatIntensity);
                gain.gain.setValueAtTime(volume, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.25);
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.musicGain);
                osc.start(time);
                osc.stop(time + 0.25);
            }
            
            // 🎹 ARPEGGIATOR
            playArp(time, freq) {
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                
                osc.type = 'square';
                osc.frequency.value = freq;
                
                const volume = 0.15 * this.combatIntensity;
                gain.gain.setValueAtTime(volume, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
                
                osc.connect(gain);
                gain.connect(this.musicGain);
                osc.start(time);
                osc.stop(time + 0.1);
            }
            
            // 🎺 LEAD MELODY
            playLead(time, freq) {
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                
                osc.type = 'triangle';
                osc.frequency.value = freq * 2;
                
                const volume = 0.2 * this.combatIntensity;
                gain.gain.setValueAtTime(volume, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.4);
                
                osc.connect(gain);
                gain.connect(this.musicGain);
                osc.start(time);
                osc.stop(time + 0.4);
            }
            
            // ðŸŒŠ PAD
            playPad(time, chord) {
                chord.forEach((freq, i) => {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    
                    osc.type = 'sine';
                    osc.frequency.value = freq * 2;
                    
                    const filter = this.audioContext.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 1000;
                    filter.Q.value = 5;
                    
                    const volume = 0.05 * (1 + this.combatIntensity * 0.5);
                    gain.gain.setValueAtTime(0, time);
                    gain.gain.linearRampToValueAtTime(volume, time + 0.5);
                    gain.gain.setValueAtTime(volume, time + 3);
                    gain.gain.linearRampToValueAtTime(0, time + 3.5);
                    
                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.musicGain);
                    osc.start(time);
                    osc.stop(time + 3.5);
                });
            }
            
            updateCombatIntensity(enemies, combo, levelProgress, bossBattle = false) {
                // Calculate target intensity
                const enemyFactor = Math.min(enemies / 12, 1);
                const comboFactor = Math.min(combo / 15, 1);
                const progressFactor = levelProgress;
                const bossFactor = bossBattle ? 0.8 : 0;
                
                this.targetIntensity = Math.min(
                    enemyFactor * 0.3 +
                    comboFactor * 0.25 +
                    progressFactor * 0.25 +
                    bossFactor * 0.2,
                    1
                );

                // 🎵 Ensure minimum intensity so music always plays during gameplay
                this.targetIntensity = Math.max(this.targetIntensity, 0.3);

                // Smooth transition
                const smoothing = 0.05;
                this.combatIntensity += (this.targetIntensity - this.combatIntensity) * smoothing;
                
                // Update boss battle state
                this.bossBattle = bossBattle;
                
                // Adjust BPM based on intensity and boss battle
                if (this.bossBattle) {
                    this.bpm = 160;
                } else {
                    this.bpm = 140 + (this.combatIntensity * 20);
                }
                
                this.beatDuration = (60 / this.bpm) * 1000;
                
                // Restart sequencer with new tempo if playing
                if (this.isPlaying && this.sequencerInterval) {
                    clearInterval(this.sequencerInterval);
                    const stepDuration = this.beatDuration / 4;
                    this.sequencerInterval = setInterval(() => {
                        this.processStep();
                        this.step = (this.step + 1) % 16;
                        if (this.step === 0) {
                            this.bar = (this.bar + 1) % 4;
                        }
                    }, stepDuration);
                }
            }
            
            // ========================================
            // 🔊 SOUND EFFECTS
            // ========================================
            
            playShoot() {
                if (!this.enabled || !this.audioContext) return;
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(800, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(200, this.audioContext.currentTime + 0.1);
                gain.gain.setValueAtTime(0.15, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                osc.connect(gain);
                gain.connect(this.sfxGain);
                osc.start();
                osc.stop(this.audioContext.currentTime + 0.1);
            }
            
            playExplosion() {
                if (!this.enabled || !this.audioContext) return;
                const noise = this.audioContext.createBufferSource();
                const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 0.3, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                noise.buffer = buffer;
                const filter = this.audioContext.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(1000, this.audioContext.currentTime);
                filter.frequency.exponentialRampToValueAtTime(100, this.audioContext.currentTime + 0.3);
                const gain = this.audioContext.createGain();
                gain.gain.setValueAtTime(0.4, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.sfxGain);
                noise.start();
                noise.stop(this.audioContext.currentTime + 0.3);
            }
            
            playPowerUp() {
                if (!this.enabled || !this.audioContext) return;
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(800, this.audioContext.currentTime + 0.2);
                gain.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                osc.connect(gain);
                gain.connect(this.sfxGain);
                osc.start();
                osc.stop(this.audioContext.currentTime + 0.2);
            }
            
            playHit() {
                if (!this.enabled || !this.audioContext) return;
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                osc.type = 'sawtooth';
                osc.frequency.value = 150;
                gain.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.05);
                osc.connect(gain);
                gain.connect(this.sfxGain);
                osc.start();
                osc.stop(this.audioContext.currentTime + 0.05);
            }
            
            playDamage() {
                if (!this.enabled || !this.audioContext) return;
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(300, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, this.audioContext.currentTime + 0.2);
                gain.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                osc.connect(gain);
                gain.connect(this.sfxGain);
                osc.start();
                osc.stop(this.audioContext.currentTime + 0.2);
            }
            
            playCombo() {
                if (!this.enabled || !this.audioContext) return;
                const osc1 = this.audioContext.createOscillator();
                const osc2 = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                osc1.type = 'sine';
                osc2.type = 'sine';
                osc1.frequency.value = 523.25;
                osc2.frequency.value = 659.25;
                gain.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.15);
                osc1.connect(gain);
                osc2.connect(gain);
                gain.connect(this.sfxGain);
                osc1.start();
                osc2.start();
                osc1.stop(this.audioContext.currentTime + 0.15);
                osc2.stop(this.audioContext.currentTime + 0.15);
            }
            
            playSuperMissile() {
                if (!this.enabled || !this.audioContext) return;
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(50, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(400, this.audioContext.currentTime + 0.5);
                gain.gain.setValueAtTime(0.5, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                osc.connect(gain);
                gain.connect(this.sfxGain);
                osc.start();
                osc.stop(this.audioContext.currentTime + 0.5);
            }
            
            playUpgrade() {
                if (!this.enabled || !this.audioContext) return;
                [0, 0.1, 0.2].forEach(delay => {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = 800 + (delay * 400);
                    gain.gain.setValueAtTime(0.15, this.audioContext.currentTime + delay);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + delay + 0.1);
                    osc.connect(gain);
                    gain.connect(this.sfxGain);
                    osc.start(this.audioContext.currentTime + delay);
                    osc.stop(this.audioContext.currentTime + delay + 0.1);
                });
            }
            
            playAbility() {
                if (!this.enabled || !this.audioContext) return;
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(600, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1200, this.audioContext.currentTime + 0.3);
                gain.gain.setValueAtTime(0.35, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                osc.connect(gain);
                gain.connect(this.sfxGain);
                osc.start();
                osc.stop(this.audioContext.currentTime + 0.3);
            }
            
            // ========================================
            // 🎙️ VOICE ANNOUNCEMENT SYSTEM
            // ========================================
            
            speak(text, rate = 1.0, pitch = 1.0) {
                if (!this.enabled) return;
                
                try {
                    window.speechSynthesis.cancel();
                    
                    const utterance = new SpeechSynthesisUtterance(text);
                    
                    const voices = window.speechSynthesis.getVoices();

                    // 🔊 FIXED: Prefer deepest American male voices (Mortal Kombat style)
                    const deepVoice = voices.find(voice =>
                        (voice.lang.startsWith('en-US')) &&
                        (voice.name.toLowerCase().includes('aaron') ||
                         voice.name.toLowerCase().includes('fred') ||
                         voice.name.toLowerCase().includes('daniel'))
                    ) || voices.find(voice =>
                        (voice.lang.startsWith('en-US')) &&
                        (voice.name.toLowerCase().includes('male') ||
                         voice.name.toLowerCase().includes('man'))
                    ) || voices.find(voice => voice.lang.startsWith('en-US')) || voices[0];

                    if (deepVoice) {
                        utterance.voice = deepVoice;
                    }

                    utterance.rate = rate;
                    utterance.pitch = pitch * 0.5; // 🔊 FIXED: Much lower pitch (50% reduction)
                    utterance.volume = 1.0;
                    
                    window.speechSynthesis.speak(utterance);
                } catch (e) {
                    console.warn('Speech Synthesis not supported:', e);
                }
            }
            
            speakCombo(comboCount) {
                if (!this.enabled) return;

                let message = '';
                let rate = 1.0;
                let pitch = 0.5; // Will be reduced further by 50% in speak()
                let currentTier = 0;

                // 🔊 Deep announcer voice - dramatic, warlike tone (MK-inspired, not MK-branded)
                if (comboCount >= 50) {
                    message = 'LEGENDARY COMBO!';
                    rate = 0.6;
                    pitch = 0.3;
                    currentTier = 5;
                } else if (comboCount >= 40) {
                    message = 'DEVASTATING!';
                    rate = 0.65;
                    pitch = 0.4;
                    currentTier = 4;
                } else if (comboCount >= 30) {
                    message = 'DOMINATING!';
                    rate = 0.7;
                    pitch = 0.5;
                    currentTier = 3;
                } else if (comboCount >= 20) {
                    message = 'OVERWHELMING!';
                    rate = 0.75;
                    pitch = 0.6;
                    currentTier = 2;
                } else if (comboCount >= 10) {
                    message = 'UNSTOPPABLE!';
                    rate = 0.8;
                    pitch = 0.7;
                    currentTier = 1;
                }

                if (currentTier > 0 && currentTier !== this.lastComboTier) {
                    this.lastComboTier = currentTier;
                    this.speak(message, rate, pitch);
                }
            }

            speakLifesteal() {
                // 🔊 Deep announcer voice for lifesteal effect
                this.speak("LIFE DRAIN!", 0.9, 0.8);
            }
            
            resetComboTier() {
                this.lastComboTier = 0;
            }
            
            speakBossDefeat() {
                if (!this.enabled) return;
                // 🔊 Deep announcer voice for boss defeat - dramatic and powerful
                this.speak("VICTORY!", 0.6, 0.4);
            }
            
            toggle() {
                this.enabled = !this.enabled;
                if (!this.enabled) {
                    this.stopMusic();
                }
                return this.enabled;
            }

            // 🚀 AAA: Volume control methods
            setMasterVolume(value) {
                if (this.masterGain) {
                    // value should be 0-1
                    this.masterGain.gain.value = Math.max(0, Math.min(1, value));
                }
            }

            setMusicVolume(value) {
                if (this.musicGain) {
                    // value should be 0-1
                    this.musicGain.gain.value = Math.max(0, Math.min(1, value));
                }
            }

            getMasterVolume() {
                return this.masterGain ? this.masterGain.gain.value : 0.7;
            }

            getMusicVolume() {
                return this.musicGain ? this.musicGain.gain.value : 1.0;
            }
        }

        // ========================================
        // 🛡️ ENHANCED WEATHER & ATMOSPHERE SYSTEMS
        // ========================================
        

        // ═══════════════════════════════════════════════════════════════════════════════
        // 🎨 MODULE: VISUAL THEMES CONFIGURATION
        // ═══════════════════════════════════════════════════════════════════════════════
        // PURPOSE: Color schemes for different levels
        // SAFE TO MODIFY: Colors, theme properties
        // ═══════════════════════════════════════════════════════════════════════════════

        const LEVEL_THEMES = [
            { 
                name: 'Cyber Neon', 
                primary: '#00ffff', 
                secondary: '#ff006e', 
                bg: '#1a0a2e',
                weatherType: 'rain',
                weatherColor: '#00ffff',
                weatherIntensity: 0.7,
                fogColor: 'rgba(0, 255, 255, 0.1)',
                fogDensity: 0.3,
                parallaxLayers: [
                    { color: '#0a1a3a', speed: 0.2, opacity: 0.3 },
                    { color: '#1a2a4a', speed: 0.4, opacity: 0.2 },
                    { color: '#2a3a5a', speed: 0.6, opacity: 0.1 }
                ]
            },
            { 
                name: 'Toxic Green', 
                primary: '#00ff00', 
                secondary: '#88ff00', 
                bg: '#0a2e0a',
                weatherType: 'toxic',
                weatherColor: '#00ff00',
                weatherIntensity: 0.8,
                fogColor: 'rgba(0, 255, 0, 0.2)',
                fogDensity: 0.5,
                parallaxLayers: [
                    { color: '#0a2e0a', speed: 0.2, opacity: 0.4 },
                    { color: '#1a3e1a', speed: 0.4, opacity: 0.3 },
                    { color: '#2a4e2a', speed: 0.6, opacity: 0.2 }
                ]
            },
            { 
                name: 'Crimson Alert', 
                primary: '#ff0033', 
                secondary: '#ff6600', 
                bg: '#2e0a0a',
                weatherType: 'embers',
                weatherColor: '#ff6600',
                weatherIntensity: 0.9,
                fogColor: 'rgba(255, 0, 0, 0.15)',
                fogDensity: 0.4,
                parallaxLayers: [
                    { color: '#2e0a0a', speed: 0.2, opacity: 0.3 },
                    { color: '#3e1a1a', speed: 0.4, opacity: 0.2 },
                    { color: '#4e2a2a', speed: 0.6, opacity: 0.1 }
                ]
            },
            { 
                name: 'Golden Sunset', 
                primary: '#ffd700', 
                secondary: '#ff8c00', 
                bg: '#2e1a0a',
                weatherType: 'dust',
                weatherColor: '#ffd700',
                weatherIntensity: 0.6,
                fogColor: 'rgba(255, 215, 0, 0.12)',
                fogDensity: 0.35,
                parallaxLayers: [
                    { color: '#2e1a0a', speed: 0.2, opacity: 0.3 },
                    { color: '#3e2a1a', speed: 0.4, opacity: 0.2 },
                    { color: '#4e3a2a', speed: 0.6, opacity: 0.1 }
                ]
            },
            { 
                name: 'Deep Purple', 
                primary: '#9d00ff', 
                secondary: '#ff00ff', 
                bg: '#1a0a2e',
                weatherType: 'nebula',
                weatherColor: '#9d00ff',
                weatherIntensity: 0.75,
                fogColor: 'rgba(157, 0, 255, 0.18)',
                fogDensity: 0.45,
                parallaxLayers: [
                    { color: '#1a0a2e', speed: 0.2, opacity: 0.4 },
                    { color: '#2a1a3e', speed: 0.4, opacity: 0.3 },
                    { color: '#3a2a4e', speed: 0.6, opacity: 0.2 }
                ]
            },
            { 
                name: 'Ice Blue', 
                primary: '#00d4ff', 
                secondary: '#0088ff', 
                bg: '#0a1a2e',
                weatherType: 'snow',
                weatherColor: '#ffffff',
                weatherIntensity: 0.85,
                fogColor: 'rgba(0, 212, 255, 0.12)',
                fogDensity: 0.3,
                parallaxLayers: [
                    { color: '#0a1a2e', speed: 0.2, opacity: 0.3 },
                    { color: '#1a2a3e', speed: 0.4, opacity: 0.2 },
                    { color: '#2a3a4e', speed: 0.6, opacity: 0.1 }
                ]
            },
            { 
                name: 'Hot Pink', 
                primary: '#ff1493', 
                secondary: '#ff69b4', 
                bg: '#2e0a1a',
                weatherType: 'sparks',
                weatherColor: '#ff1493',
                weatherIntensity: 0.8,
                fogColor: 'rgba(255, 20, 147, 0.12)',
                fogDensity: 0.3,
                parallaxLayers: [
                    { color: '#2e0a1a', speed: 0.2, opacity: 0.3 },
                    { color: '#3e1a2a', speed: 0.4, opacity: 0.2 },
                    { color: '#4e2a3a', speed: 0.6, opacity: 0.1 }
                ]
            },
            { 
                name: 'Electric Yellow', 
                primary: '#ffff00', 
                secondary: '#ffaa00', 
                bg: '#2e2e0a',
                weatherType: 'lightning',
                weatherColor: '#ffff00',
                weatherIntensity: 0.7,
                fogColor: 'rgba(255, 255, 0, 0.1)',
                fogDensity: 0.25,
                parallaxLayers: [
                    { color: '#2e2e0a', speed: 0.2, opacity: 0.3 },
                    { color: '#3e3e1a', speed: 0.4, opacity: 0.2 },
                    { color: '#4e4e2a', speed: 0.6, opacity: 0.1 }
                ]
            },
        ];

        function getTheme(level) {
            return LEVEL_THEMES[(level - 1) % LEVEL_THEMES.length];
        }

        // ========================================
        // ENHANCED WEATHER PARTICLE CLASS
        // ========================================

        // ═══════════════════════════════════════════════════════════════════════════════
        // 🌦️ MODULE: ATMOSPHERE SYSTEMS
        // ═══════════════════════════════════════════════════════════════════════════════
        // PURPOSE: Weather particles, fog layers, lightning effects
        // SAFE TO MODIFY: Particle counts, effects intensity
        // DO NOT REMOVE: These create visual depth
        // ═══════════════════════════════════════════════════════════════════════════════

        class WeatherParticle {
            constructor(x, y, theme) {
                this.x = x;
                this.y = y;
                this.theme = theme;
                this.type = theme.weatherType;
                this.baseSpeed = 2 + Math.random() * 3;
                this.speed = this.baseSpeed * theme.weatherIntensity;
                
                switch(this.type) {
                    case 'rain':
                        this.width = 1;
                        this.height = 10 + Math.random() * 15;
                        this.angle = Math.PI / 6; // Diagonal rain
                        this.alpha = 0.3 + Math.random() * 0.4;
                        break;
                    
                    case 'snow':
                        this.size = 2 + Math.random() * 4;
                        this.sway = Math.sin(Date.now() / 1000) * 0.5;
                        this.swaySpeed = 0.02 + Math.random() * 0.03;
                        this.alpha = 0.4 + Math.random() * 0.6;
                        break;
                    
                    case 'toxic':
                        this.size = 15 + Math.random() * 25;
                        this.vx = (Math.random() - 0.5) * 0.5;
                        this.vy = 0.5 + Math.random() * 1;
                        this.alpha = 0.1 + Math.random() * 0.2;
                        this.pulseSpeed = 0.02 + Math.random() * 0.03;
                        this.pulseOffset = Math.random() * Math.PI * 2;
                        break;
                    
                    case 'embers':
                        this.size = 2 + Math.random() * 3;
                        this.vx = (Math.random() - 0.5) * 0.3;
                        this.vy = -0.5 - Math.random() * 1.5; // Rise up
                        this.alpha = 0.5 + Math.random() * 0.5;
                        this.flicker = 0;
                        break;
                    
                    case 'dust':
                        this.size = 3 + Math.random() * 5;
                        this.vx = (Math.random() - 0.5) * 0.8;
                        this.vy = 0.3 + Math.random() * 0.7;
                        this.alpha = 0.2 + Math.random() * 0.3;
                        this.rotation = Math.random() * Math.PI * 2;
                        this.rotationSpeed = (Math.random() - 0.5) * 0.05;
                        break;
                    
                    case 'nebula':
                        this.size = 20 + Math.random() * 40;
                        this.vx = (Math.random() - 0.5) * 0.3;
                        this.vy = 0.2 + Math.random() * 0.5;
                        this.alpha = 0.05 + Math.random() * 0.1;
                        this.pulseSpeed = 0.01 + Math.random() * 0.02;
                        this.pulseOffset = Math.random() * Math.PI * 2;
                        break;
                    
                    case 'sparks':
                        this.size = 1 + Math.random() * 2;
                        this.vx = (Math.random() - 0.5) * 2;
                        this.vy = 1 + Math.random() * 2;
                        this.alpha = 0.6 + Math.random() * 0.4;
                        this.life = 30 + Math.random() * 30;
                        this.maxLife = this.life;
                        break;
                    
                    case 'lightning':
                        this.size = 2 + Math.random() * 3;
                        this.alpha = 0.4 + Math.random() * 0.4;
                        this.flashChance = 0.001; // Very rare lightning flashes
                        break;
                }
            }
            
            update(deltaTime, canvasHeight, canvasWidth) {
                switch(this.type) {
                    case 'rain':
                        this.x += Math.cos(this.angle) * this.speed;
                        this.y += Math.sin(this.angle) * this.speed;
                        break;
                    
                    case 'snow':
                        this.sway += this.swaySpeed;
                        this.x += Math.sin(this.sway) * 0.5;
                        this.y += this.speed * 0.5;
                        break;
                    
                    case 'toxic':
                    case 'nebula':
                        this.x += this.vx;
                        this.y += this.vy;
                        const pulse = Math.sin(Date.now() / 1000 * this.pulseSpeed + this.pulseOffset);
                        this.currentAlpha = this.alpha * (0.7 + pulse * 0.3);
                        break;
                    
                    case 'embers':
                        this.x += this.vx;
                        this.y += this.vy;
                        this.flicker = Math.random();
                        this.alpha *= 0.995; // Fade out slowly
                        break;
                    
                    case 'dust':
                        this.x += this.vx;
                        this.y += this.vy;
                        this.rotation += this.rotationSpeed;
                        break;
                    
                    case 'sparks':
                        this.x += this.vx;
                        this.y += this.vy;
                        this.life--;
                        this.alpha = (this.life / this.maxLife) * 0.8;
                        break;
                    
                    case 'lightning':
                        this.y += this.speed;
                        break;
                }
                
                // Wrap around or respawn
                if (this.y > canvasHeight + 50) {
                    this.y = -50;
                    this.x = Math.random() * canvasWidth;
                }
                if (this.x < -50) this.x = canvasWidth + 50;
                if (this.x > canvasWidth + 50) this.x = -50;
                
                // Respawn sparks when they die
                if (this.type === 'sparks' && this.life <= 0) {
                    this.y = -50;
                    this.x = Math.random() * canvasWidth;
                    this.life = 30 + Math.random() * 30;
                    this.maxLife = this.life;
                }
                
                // Respawn embers when faded
                if (this.type === 'embers' && this.alpha < 0.1) {
                    this.y = canvasHeight + 50;
                    this.x = Math.random() * canvasWidth;
                    this.alpha = 0.5 + Math.random() * 0.5;
                }
            }
            
            render(ctx) {
                ctx.save();
                const displayAlpha = this.currentAlpha !== undefined ? this.currentAlpha : this.alpha;
                ctx.globalAlpha = displayAlpha;
                ctx.fillStyle = this.theme.weatherColor;
                
                switch(this.type) {
                    case 'rain':
                        ctx.strokeStyle = this.theme.weatherColor;
                        ctx.lineWidth = this.width;
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        ctx.lineTo(
                            this.x + Math.cos(this.angle) * this.height,
                            this.y + Math.sin(this.angle) * this.height
                        );
                        ctx.stroke();
                        break;
                    
                    case 'snow':
                        ctx.shadowBlur = 5;
                        ctx.shadowColor = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    
                    case 'toxic':
                    case 'nebula':
                        const gradient = ctx.createRadialGradient(
                            this.x, this.y, 0,
                            this.x, this.y, this.size
                        );
                        gradient.addColorStop(0, this.theme.weatherColor);
                        gradient.addColorStop(1, 'transparent');
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    
                    case 'embers':
                        if (this.flicker > 0.3) {
                            ctx.shadowBlur = 8;
                            ctx.shadowColor = this.theme.weatherColor;
                            ctx.fillStyle = this.theme.weatherColor;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                    
                    case 'dust':
                        ctx.translate(this.x, this.y);
                        ctx.rotate(this.rotation);
                        ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                        break;
                    
                    case 'sparks':
                        ctx.shadowBlur = 5;
                        ctx.shadowColor = this.theme.weatherColor;
                        ctx.fillRect(this.x, this.y, this.size, this.size);
                        break;
                    
                    case 'lightning':
                        ctx.fillRect(this.x, this.y, this.size, this.size);
                        break;
                }
                
                ctx.restore();
            }
        }

        // ========================================
        // FOG LAYER CLASS
        // ========================================
        class FogLayer {
            constructor(canvasWidth, canvasHeight, theme) {
                this.width = canvasWidth;
                this.height = canvasHeight;
                this.theme = theme;
                this.clouds = [];
                
                // Create 3-5 fog clouds
                const numClouds = 3 + Math.floor(Math.random() * 3);
                for (let i = 0; i < numClouds; i++) {
                    this.clouds.push({
                        x: Math.random() * canvasWidth,
                        y: Math.random() * canvasHeight,
                        size: 100 + Math.random() * 200,
                        speed: 0.1 + Math.random() * 0.3,
                        opacity: 0.05 + Math.random() * 0.1
                    });
                }
            }
            
            update(deltaTime) {
                this.clouds.forEach(cloud => {
                    cloud.x += cloud.speed;
                    if (cloud.x > this.width + cloud.size) {
                        cloud.x = -cloud.size;
                        cloud.y = Math.random() * this.height;
                    }
                });
            }
            
            render(ctx) {
                ctx.save();
                this.clouds.forEach(cloud => {
                    const gradient = ctx.createRadialGradient(
                        cloud.x, cloud.y, 0,
                        cloud.x, cloud.y, cloud.size
                    );
                    
                    // Parse the fog color to get RGBA values
                    const fogMatch = this.theme.fogColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
                    if (fogMatch) {
                        const [_, r, g, b] = fogMatch;
                        gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${cloud.opacity * this.theme.fogDensity})`);
                        gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, ${cloud.opacity * this.theme.fogDensity * 0.5})`);
                        gradient.addColorStop(1, 'transparent');
                    }
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, this.width, this.height);
                });
                ctx.restore();
            }
        }

        // ========================================
        // LIGHTNING FLASH EFFECT
        // ========================================
        class LightningEffect {
            constructor(canvasWidth, canvasHeight) {
                this.width = canvasWidth;
                this.height = canvasHeight;
                this.active = false;
                this.intensity = 0;
                this.duration = 0;
            }
            
            trigger() {
                if (Math.random() < 0.002) { // Very rare
                    this.active = true;
                    this.intensity = 0.6 + Math.random() * 0.4;
                    this.duration = 50 + Math.random() * 100;
                }
            }
            
            update(deltaTime) {
                if (this.active) {
                    this.duration -= deltaTime;
                    if (this.duration <= 0) {
                        this.active = false;
                        this.intensity = 0;
                    } else {
                        // Flicker effect
                        this.intensity *= 0.85;
                    }
                }
            }
            
            render(ctx) {
                if (this.active && this.intensity > 0.1) {
                    ctx.save();
                    ctx.fillStyle = `rgba(255, 255, 255, ${this.intensity * 0.3})`;
                    ctx.fillRect(0, 0, this.width, this.height);
                    
                    // Draw lightning bolt
                    if (this.intensity > 0.5) {
                        ctx.strokeStyle = `rgba(255, 255, 255, ${this.intensity})`;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        let x = Math.random() * this.width;
                        let y = 0;
                        ctx.moveTo(x, y);
                        
                        while (y < this.height) {
                            x += (Math.random() - 0.5) * 50;
                            y += 30 + Math.random() * 40;
                            ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                }
            }
        }

        // ========================================
        // SHIP TYPES - WITH NEW LEGENDARY SHIPS
        // ========================================

        // ═══════════════════════════════════════════════════════════════════════════════
        // 🚀 MODULE: SHIP CONFIGURATION
        // ═══════════════════════════════════════════════════════════════════════════════
        // PURPOSE: All playable ships, stats, abilities, visuals
        // SAFE TO MODIFY: Ship costs, stats, descriptions
        // TO ADD NEW SHIP: Copy existing pattern and modify
        // ═══════════════════════════════════════════════════════════════════════════════

        const SHIP_TYPES = {
            fighter: {
                id: 'fighter',
                name: 'INTERCEPTOR',
                icon: '⚔️',
                cost: 0,
                speed: 1.0,
                size: 1.0,
                shieldCapacity: 50, // ⚖️ BALANCE: Increased from 30 to 50 for better survivability
                critChance: 0.15, // 🎯 AAA: New parameter - 15% crit chance (up from base 10%)
                desc: 'Balanced fighter',
                ability: null,
                render: (ctx, x, y, w, h, theme) => {
                    ctx.fillStyle = theme.primary;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = theme.primary;
                    ctx.beginPath();
                    ctx.moveTo(x, y - h/2);
                    ctx.lineTo(x - w/2, y + h/2);
                    ctx.lineTo(x + w/2, y + h/2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = theme.secondary;
                    ctx.beginPath();
                    ctx.arc(x, y, w/4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            },
            rocket: {
                id: 'rocket',
                name: 'GOLIATH',
                icon: '🚀',
                cost: 500,
                speed: 0.8,
                size: 1.3,
                shieldCapacity: 50, // 🛡️ AAA: Tank ship has high shield capacity
                critChance: 0.08, // 🎯 AAA: Low crit chance (below base 10%)
                desc: 'Heavy tank',
                ability: null,
                render: (ctx, x, y, w, h, theme) => {
                    ctx.fillStyle = theme.primary;
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = theme.primary;
                    ctx.fillRect(x - w/2, y - h/2, w, h);
                    ctx.fillStyle = theme.secondary;
                    ctx.beginPath();
                    ctx.moveTo(x, y - h/2 - 10);
                    ctx.lineTo(x - w/2, y - h/2);
                    ctx.lineTo(x + w/2, y - h/2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(x - w/2 - 5, y + h/2 - 15, 8, 15);
                    ctx.fillRect(x + w/2 - 3, y + h/2 - 15, 8, 15);
                    ctx.shadowBlur = 0;
                }
            },
            starfighter: {
                id: 'starfighter',
                name: 'VALKYRIE',
                icon: '⚡',
                cost: 800,
                speed: 1.3,
                size: 0.8,
                shieldCapacity: 15, // 🛡️ AAA: Speed ship has low shield
                critChance: 0.28, // 🎯 AAA: High crit chance for glass cannon build
                desc: 'Speed demon',
                ability: null,
                render: (ctx, x, y, w, h, theme) => {
                    ctx.fillStyle = theme.primary;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = theme.primary;
                    ctx.fillRect(x - w/4, y - h/2, w/2, h);
                    ctx.beginPath();
                    ctx.moveTo(x - w/4, y);
                    ctx.lineTo(x - w/2 - 10, y + h/3);
                    ctx.lineTo(x - w/4, y + h/3);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(x + w/4, y);
                    ctx.lineTo(x + w/2 + 10, y + h/3);
                    ctx.lineTo(x + w/4, y + h/3);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = theme.secondary;
                    ctx.fillRect(x - w/6, y - h/2 + 5, w/3, 10);
                    ctx.shadowBlur = 0;
                }
            },
            phantom: {
                id: 'phantom',
                name: 'PHANTOM',
                icon: '👻',
                cost: 1500,
                speed: 1.1,
                size: 0.9,
                shieldCapacity: 25, // 🛡️ AAA: Moderate shield for balanced evasion ship
                critChance: 0.22, // 🎯 AAA: Good crit for hit-and-run tactics
                desc: 'Stealth specialist',
                legendary: true,
                ability: {
                    name: 'PHASE SHIFT',
                    desc: 'Dodge on lane change',
                    icon: '✨'
                },
                render: (ctx, x, y, w, h, theme, alpha = 1) => {
                    ctx.globalAlpha = alpha * 0.7;
                    ctx.fillStyle = '#8a2be2';
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#8a2be2';
                    
                    ctx.beginPath();
                    ctx.moveTo(x, y - h/2);
                    ctx.lineTo(x - w/2, y);
                    ctx.lineTo(x, y + h/2);
                    ctx.lineTo(x + w/2, y);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(x, y, w/5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;
                }
            },
            titan: {
                id: 'titan',
                name: 'TITAN',
                icon: '🛡️',
                cost: 2000,
                speed: 0.6,
                size: 1.5,
                shieldCapacity: 70, // 🛡️ AAA: Highest shield capacity - ultimate tank
                critChance: 0.05, // 🎯 AAA: Very low crit - focused on defense
                desc: 'Ultimate defense',
                legendary: true,
                ability: {
                    name: 'FORTRESS MODE',
                    desc: '+50% armor on hit',
                    icon: '🛡️'
                },
                render: (ctx, x, y, w, h, theme) => {
                    ctx.fillStyle = '#4169e1';
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#4169e1';
                    
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i - Math.PI / 2;
                        const px = x + Math.cos(angle) * (w/2);
                        const py = y + Math.sin(angle) * (h/2);
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(x, y - h/3);
                    ctx.lineTo(x - w/3, y);
                    ctx.lineTo(x, y + h/3);
                    ctx.lineTo(x + w/3, y);
                    ctx.closePath();
                    ctx.stroke();
                    
                    ctx.shadowBlur = 0;
                }
            },
            phoenix: {
                id: 'phoenix',
                name: 'PHOENIX',
                icon: '🔥',
                cost: 2500,
                speed: 1.0,
                size: 1.0,
                shieldCapacity: 40, // 🛡️ AAA: Balanced shield - sustain through rebirth
                critChance: 0.18, // 🎯 AAA: Balanced crit chance
                desc: 'Rises from ashes',
                legendary: true,
                ability: {
                    name: 'REBIRTH',
                    desc: 'Revive once per level',
                    icon: '♻️'
                },
                render: (ctx, x, y, w, h, theme) => {
                    ctx.fillStyle = '#ff4500';
                    ctx.shadowBlur = 35;
                    ctx.shadowColor = '#ff4500';

                    ctx.beginPath();
                    ctx.moveTo(x, y - h/2);
                    ctx.quadraticCurveTo(x - w/2, y, x - w/3, y + h/2);
                    ctx.lineTo(x, y + h/3);
                    ctx.lineTo(x + w/3, y + h/2);
                    ctx.quadraticCurveTo(x + w/2, y, x, y - h/2);
                    ctx.closePath();
                    ctx.fill();

                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, w/3);
                    gradient.addColorStop(0, '#ffff00');
                    gradient.addColorStop(0.5, '#ff8c00');
                    gradient.addColorStop(1, '#ff4500');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, w/3, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.shadowBlur = 0;
                }
            },
            // 🚀 AAA: NEW SHIP 1 - NOVA (Rapid Fire Specialist)
            nova: {
                id: 'nova',
                name: 'NOVA',
                icon: '⭐',
                cost: 3000,
                speed: 1.15,
                size: 0.9,
                shieldCapacity: 35,
                critChance: 0.20,
                desc: 'Rapid fire burst',
                legendary: true,
                ability: {
                    name: 'BURST FIRE',
                    desc: 'Triple shot burst',
                    icon: '💫'
                },
                render: (ctx, x, y, w, h, theme) => {
                    ctx.fillStyle = '#ffff00';
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#ffff00';

                    // Star-shaped ship
                    ctx.beginPath();
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI / 4) * i - Math.PI / 2;
                        const radius = (i % 2 === 0) ? w/2 : w/4;
                        const px = x + Math.cos(angle) * radius;
                        const py = y + Math.sin(angle) * radius;
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(x, y, w/5, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.shadowBlur = 0;
                }
            },
            // 🚀 AAA: NEW SHIP 2 - SPECTRE (Assassin)
            spectre: {
                id: 'spectre',
                name: 'SPECTRE',
                icon: '💀',
                cost: 3500,
                speed: 1.4,
                size: 0.7,
                shieldCapacity: 10,
                critChance: 0.35, // Highest crit chance!
                desc: 'Glass cannon',
                legendary: true,
                ability: {
                    name: 'DEATH MARK',
                    desc: 'Next hit does 5x damage',
                    icon: '☠️'
                },
                render: (ctx, x, y, w, h, theme) => {
                    ctx.fillStyle = '#000000';
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#ff0000';

                    // Sleek assassin shape
                    ctx.beginPath();
                    ctx.moveTo(x, y - h/2);
                    ctx.lineTo(x - w/4, y);
                    ctx.lineTo(x - w/3, y + h/2);
                    ctx.lineTo(x + w/3, y + h/2);
                    ctx.lineTo(x + w/4, y);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // Red core
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(x, y, w/6, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.shadowBlur = 0;
                }
            },
            // 🚀 AAA: NEW SHIP 3 - AEGIS (Ultimate Tank)
            aegis: {
                id: 'aegis',
                name: 'AEGIS',
                icon: '🛡️',
                cost: 4000,
                speed: 0.5,
                size: 1.6,
                shieldCapacity: 90, // Highest shield!
                critChance: 0.03, // Very low crit
                desc: 'Impenetrable fortress',
                legendary: true,
                ability: {
                    name: 'BARRIER',
                    desc: 'Invulnerable for 5s',
                    icon: '🔰'
                },
                render: (ctx, x, y, w, h, theme) => {
                    ctx.fillStyle = '#1e90ff';
                    ctx.shadowBlur = 35;
                    ctx.shadowColor = '#1e90ff';

                    // Shield shape
                    ctx.beginPath();
                    ctx.moveTo(x, y - h/2);
                    ctx.quadraticCurveTo(x - w/2, y - h/4, x - w/2, y + h/4);
                    ctx.lineTo(x, y + h/2);
                    ctx.lineTo(x + w/2, y + h/4);
                    ctx.quadraticCurveTo(x + w/2, y - h/4, x, y - h/2);
                    ctx.closePath();
                    ctx.fill();

                    // Cross emblem
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(x, y - h/4);
                    ctx.lineTo(x, y + h/4);
                    ctx.moveTo(x - w/4, y);
                    ctx.lineTo(x + w/4, y);
                    ctx.stroke();

                    ctx.shadowBlur = 0;
                }
            },
            // 🚀 AAA: NEW SHIP 4 - WRAITH (Life Stealer)
            wraith: {
                id: 'wraith',
                name: 'WRAITH',
                icon: '🌙',
                cost: 4500,
                speed: 1.05,
                size: 1.0,
                shieldCapacity: 45,
                critChance: 0.12,
                desc: 'Drains life from enemies',
                legendary: true,
                ability: {
                    name: 'SOUL DRAIN',
                    desc: 'Steal 30% damage as HP',
                    icon: '💀'
                },
                render: (ctx, x, y, w, h, theme) => {
                    ctx.fillStyle = '#4b0082';
                    ctx.shadowBlur = 40;
                    ctx.shadowColor = '#9370db';

                    // Crescent moon shape
                    ctx.beginPath();
                    ctx.arc(x - w/6, y, w/2, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(x + w/6, y, w/2.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalCompositeOperation = 'source-over';

                    // Trailing spirits
                    for (let i = 0; i < 3; i++) {
                        ctx.globalAlpha = 0.3 - (i * 0.1);
                        ctx.fillStyle = '#9370db';
                        ctx.beginPath();
                        ctx.arc(x, y + h/2 + (i * 10), w/5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;

                    ctx.shadowBlur = 0;
                }
            }
        };

        // ========================================
        // ACHIEVEMENT SYSTEM
        // ========================================

        // ═══════════════════════════════════════════════════════════════════════════════
        // 🏆 MODULE: ACHIEVEMENT SYSTEM
        // ═══════════════════════════════════════════════════════════════════════════════
        // PURPOSE: Track player accomplishments, unlock notifications
        // SAFE TO MODIFY: Add new achievements, change requirements
        // DO NOT REMOVE: System must stay intact
        // ═══════════════════════════════════════════════════════════════════════════════

        class AchievementManager {
            constructor() {
                this.achievements = {
                    firstBlood: { id: 'firstBlood', icon: '🎯', name: 'First Blood', desc: 'Complete Level 1', unlocked: false },
                    comboMaster: { id: 'comboMaster', icon: '🔥', name: 'Combo Master', desc: 'Reach 10x combo', unlocked: false },
                    collector: { id: 'collector', icon: '⚡', name: 'Collector', desc: 'Use all 3 power-up types', unlocked: false },
                    bossSlayer: { id: 'bossSlayer', icon: '👑', name: 'Boss Slayer', desc: 'Defeat your first boss', unlocked: false },
                    untouchable: { id: 'untouchable', icon: '🛡️', name: 'Untouchable', desc: 'Complete level without damage', unlocked: false },
                    creditBaron: { id: 'creditBaron', icon: '💰', name: 'Credit Baron', desc: 'Earn 1000 total credits', unlocked: false },
                    speedDemon: { id: 'speedDemon', icon: '⚡', name: 'Speed Demon', desc: 'Complete a level in under 60s', unlocked: false },
                    survivor: { id: 'survivor', icon: '🏅', name: 'Survivor', desc: 'Reach level 10', unlocked: false },
                    legendary: { id: 'legendary', icon: '✨', name: 'Legendary Pilot', desc: 'Own all ships', unlocked: false }
                };
                this.powerUpsUsed = new Set();
                this.newlyUnlocked = [];
                this.load();
            }
            
            check(type, value = null) {
                const ach = this.achievements[type];
                if (!ach || ach.unlocked) return false;
                let unlock = false;
                switch(type) {
                    case 'firstBlood': unlock = value === 1; break;
                    case 'comboMaster': unlock = value >= 10; break;
                    case 'collector': unlock = this.powerUpsUsed.size >= 3; break;
                    case 'bossSlayer': unlock = value % 5 === 0; break;
                    case 'untouchable': unlock = value === true; break;
                    case 'creditBaron': unlock = value >= 1000; break;
                    case 'speedDemon': unlock = value < 60000; break;
                    case 'survivor': unlock = value >= 10; break;
                    case 'legendary': unlock = value >= 6; break;
                }
                if (unlock) {
                    ach.unlocked = true;
                    this.newlyUnlocked.push(ach);
                    this.save();
                    return true;
                }
                return false;
            }
            
            usedPowerUp(type) {
                this.powerUpsUsed.add(type);
                this.check('collector');
            }
            
            getNewlyUnlocked() {
                const temp = [...this.newlyUnlocked];
                this.newlyUnlocked = [];
                return temp;
            }
            
            save() {
                const data = {};
                Object.keys(this.achievements).forEach(key => {
                    data[key] = this.achievements[key].unlocked;
                });
                localStorage.setItem('lastwar_achievements', JSON.stringify(data));
            }
            
            load() {
                const saved = localStorage.getItem('lastwar_achievements');
                if (saved) {
                    const data = JSON.parse(saved);
                    Object.keys(data).forEach(key => {
                        if (this.achievements[key]) {
                            this.achievements[key].unlocked = data[key];
                        }
                    });
                }
            }
            
            getAll() {
                return Object.values(this.achievements);
            }
        }

        // ========================================
        // MAIN GAME CLASS
        // ========================================

        // ═══════════════════════════════════════════════════════════════════════════════
        // 🎮 MODULE: CORE GAME ENGINE
        // ═══════════════════════════════════════════════════════════════════════════════
        // PURPOSE: Main game loop, state management, input handling, rendering
        // ⚠️ CAUTION: This is the heart of the game. Changes here affect everything.
        // 
        // COMMON MODIFICATIONS IN THIS MODULE:
        // - 🏁 LEVEL PROGRESSION (search: "// 🏁 LEVEL PROGRESSION")
        // - 💰 UPGRADE COSTS (search: "// 💰 UPGRADE COSTS")
        // - 🎁 POWER-UP DROPS (search: "// 🎁 POWER-UP DROPS")
        // - 🎯 COMBO SYSTEM (search: "// 🎯 COMBO SYSTEM")
        // 
        // DO NOT MODIFY: Core game loop, rendering pipeline, state machine
        // ═══════════════════════════════════════════════════════════════════════════════

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.responsiveCanvas = new ResponsiveCanvas(this.canvas, 800, 600);
                this.width = 800;
                this.height = 600;
                
                this.state = 'MENU';
                this.currentLevel = 1;
                this.selectedLevel = 1;
                this.maxUnlockedLevel = 1;
                this.levelStars = {};
                
                this.bossBattleActive = false;
                this.bossBattlePhase = 'NONE';
                
                this.credits = 0;
                this.upgrades = {
                    armor: 0,
                    firepower: 0,
                    attackSpeed: 0,
                    health: 0
                };
                
                this.currentShip = 'fighter';
                this.ownedShips = ['fighter'];
                
                this.player = null;
                this.enemies = [];
                this.projectiles = [];
                this.enemyProjectiles = [];
                this.particles = [];
                this.weatherParticles = [];
                this.powerUps = [];
                this.floatingTexts = [];
                this.damageFields = []; // 🌈 NEW: For Ultimate Annihilation lingering damage
                
                this.levelProgress = 0;
                this.levelDistance = 0;
                this.enemiesKilled = 0;
                this.creditsThisRun = 0;
                this.damageTaken = 0;
                this.levelStartTime = 0;
                
                this.combo = 0;
                this.comboTimer = 0;
                this.maxCombo = 0;
                this.comboDisplayTime = 0;
                this.superMissileReady = false;
                
                this.screenShake = { x: 0, y: 0, intensity: 0 };
                this.slowMotion = 1;
                this.slowMotionTimer = 0;
                this.hitStop = 0;
                this.flashIntensity = 0;
                
                this.currentTheme = LEVEL_THEMES[0];
                this.currentTab = 'levels';
                
                // 🛡️ NEW: Atmosphere systems
                this.fogLayer = null;
                this.lightningEffect = null;
                this.parallaxOffset = 0;
                
                this.soundEnabled = true;
                this.audio = new AudioManager();
                this.achievements = new AchievementManager();

                // 🔫 Boss Weapon System
                this.weaponCharges = new WeaponChargeSystem(this);
                this.weaponWheel = new RadialWeaponWheel(this);
                this.activeWeapons = []; // Currently active weapon instances
                this.timeScale = 1.0; // For slow-motion effects

                this.keys = {};
                this.touches = { startX: 0, startY: 0 };
                this.mousePos = { x: 0, y: 0 };
                
                this.lastTime = 0;
                this.enemySpawnTimer = 0;
                this.backgroundOffset = 0;
                
                this.bossSpawned = false;
                this.boss = null;
                this.showingIntro = false;
                this.introTimer = 0;
                this.bossWarning = false;
                this.bossWarningTimer = 0;
                this.bossDefeated = false; // 🔥 NEW: Track boss defeat state
                this.bossDefeatTimer = 0;  // 🔥 NEW: Timer for boss defeat sequence
                this.bossVictoryData = null; // 🎬 ULTIMATE: Cinematic victory data

                // 🚀 AAA: Lifetime stats tracking
                this.lifetimeStats = {
                    totalKills: 0,
                    totalCreditsEarned: 0,
                    totalDamageTaken: 0,
                    totalDamageDealt: 0,
                    totalBossesDefeated: 0,
                    totalLevelsCompleted: 0,
                    totalPlaytime: 0,
                    highestCombo: 0,
                    totalPowerUpsCollected: 0,
                    totalEliteKills: 0,
                    perfectLevels: 0, // No damage taken
                    totalDeaths: 0
                };

                this.init();
            }
            
            init() {
                this.setupInput();
                this.loadProgress();
                this.updateUI();
                this.gameLoop();
            }
            
            setupInput() {
                window.addEventListener('keydown', (e) => {
                    this.keys[e.key] = true;
                    if (this.state === 'PLAYING') {
                        if (e.key === 'Escape' || e.key === 'p' || e.key === 'P') {
                            this.pause();
                        }
                        if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                            this.player.moveLeft();
                        }
                        if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                            this.player.moveRight();
                        }
                        if ((e.key === ' ' || e.key === 'Spacebar') && this.player) {
                            this.player.useAbility();
                        }

                        // 🔫 Weapon wheel keyboard controls
                        if (this.weaponWheel && this.weaponWheel.visible) {
                            const weaponMap = {
                                '1': 'freeze',
                                '2': 'drone',
                                '3': 'stink',
                                '4': 'shock',
                                '5': 'bomb'
                            };

                            if (weaponMap[e.key]) {
                                this.weaponWheel.selectWeapon(weaponMap[e.key]);
                            }
                        }

                        // 🔫 Toggle weapon wheel with 'W' key during boss battles
                        if (e.key.toLowerCase() === 'w' && this.boss && this.boss.hp > 0) {
                            if (this.weaponWheel.visible) {
                                this.weaponWheel.hide();
                            } else {
                                this.weaponWheel.show();
                            }
                        }
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    this.keys[e.key] = false;
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    this.mousePos = this.responsiveCanvas.getMousePos(e.clientX, e.clientY);
                });
                
                this.canvas.addEventListener('click', (e) => {
                    if (this.state === 'PLAYING') {
                        const pos = this.responsiveCanvas.getMousePos(e.clientX, e.clientY);

                        // 🔫 Check weapon wheel click first
                        if (this.weaponWheel && this.weaponWheel.visible) {
                            const weaponId = this.weaponWheel.getWeaponAtPosition(pos.x, pos.y);
                            if (weaponId) {
                                this.weaponWheel.selectWeapon(weaponId);
                                return; // Don't process other clicks
                            }
                        }

                        this.handleHUDClick(pos.x, pos.y);
                    }
                });
                
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const pos = this.responsiveCanvas.getMousePos(touch.clientX, touch.clientY);

                    this.touches.startX = touch.clientX;
                    this.touches.startY = touch.clientY;

                    if (this.state === 'PLAYING') {
                        // 🔫 Check weapon wheel tap first
                        if (this.weaponWheel && this.weaponWheel.visible) {
                            const weaponId = this.weaponWheel.getWeaponAtPosition(pos.x, pos.y);
                            if (weaponId) {
                                this.weaponWheel.selectWeapon(weaponId);
                                return; // Don't process other touches
                            }
                        }

                        this.handleHUDClick(pos.x, pos.y);
                    }
                }, { passive: false });
                
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                }, { passive: false });
                
                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (this.state === 'PLAYING') {
                        const touch = e.changedTouches[0];
                        const deltaX = touch.clientX - this.touches.startX;
                        const deltaY = touch.clientY - this.touches.startY;
                        
                        if (Math.abs(deltaX) > 50 && Math.abs(deltaX) > Math.abs(deltaY)) {
                            if (deltaX < 0) {
                                this.player.moveLeft();
                            } else {
                                this.player.moveRight();
                            }
                        } else if (Math.abs(deltaY) < 30 && Math.abs(deltaX) < 30) {
                            if (this.player) this.player.useAbility();
                        }
                    }
                }, { passive: false });
            }
            
            handleHUDClick(x, y) {
                const padding = 20;
                if (x >= padding && x <= padding + 40 && y >= padding && y <= padding + 40) {
                    this.pause();
                }
                else if (x >= padding + 50 && x <= padding + 90 && y >= padding && y <= padding + 40) {
                    this.toggleSound();
                }
                else if (x >= padding + 100 && x <= padding + 140 && y >= padding && y <= padding + 40) {
                    if (confirm('Exit to menu? Progress will be saved.')) {
                        this.exitToMenu();
                    }
                }
            }
            
            showScreen(screenId) {
                document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
                // 🎬 Clean up boss-victory styling from modals
                document.querySelectorAll('.modal').forEach(m => m.classList.remove('boss-victory'));
                if (screenId) document.getElementById(screenId).classList.add('active');
            }
            
            showTab(tab) {
                this.currentTab = tab;
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                event.target.classList.add('active');
                
                document.getElementById('levelsTab').style.display = tab === 'levels' ? 'block' : 'none';
                document.getElementById('shipsTab').style.display = tab === 'ships' ? 'block' : 'none';
                document.getElementById('upgradesTab').style.display = tab === 'upgrades' ? 'block' : 'none';
            }
            
            showMainMenu() {
                this.state = 'MENU';
                this.audio.stopMusic();
                // Clear active weapons to prevent memory leaks
                this.activeWeapons.length = 0;
                this.showScreen('mainMenu');
            }
            
            showLevelSelect() {
                this.state = 'LEVEL_SELECT';
                this.updateLevelGrid();
                this.updateUpgradeCards();
                this.updateShipCards();
                this.updateAchievementsMini();
                this.updateUI();
                this.showScreen('levelSelect');
            }
            
            showAchievements() {
                this.updateAchievementsList();
                this.showScreen('achievementsScreen');
            }
            
            showGameOver() {
                this.state = 'GAME_OVER';
                this.audio.stopMusic();
                // Clear active weapons to prevent memory leaks
                this.activeWeapons.length = 0;

                const stars = this.calculateStars();

                // 🐛 FIX: Preserve 75% of earned credits even on death (positive feedback)
                const deathPenalty = 0.75; // Player keeps 75% of earned credits
                const creditsToAward = Math.floor(this.creditsThisRun * deathPenalty);
                this.credits += creditsToAward;

                document.getElementById('earnedCredits').textContent = this.creditsThisRun;
                document.getElementById('distanceTraveled').textContent = Math.floor(this.levelDistance / 10);
                document.getElementById('maxCombo').textContent = this.maxCombo;
                document.getElementById('starsEarned').textContent = stars;

                if (!this.levelStars[this.currentLevel] || stars > this.levelStars[this.currentLevel]) {
                    this.levelStars[this.currentLevel] = stars;
                    this.saveProgress();
                }

                this.updateUI();
                this.showScreen('gameOver');
            }
            
            showLevelComplete() {
                this.state = 'LEVEL_COMPLETE';
                this.audio.stopMusic();
                // Clear active weapons to prevent memory leaks
                this.activeWeapons.length = 0;

                // 🔫 Hide weapon wheel and reset charges
                if (this.weaponWheel) {
                    this.weaponWheel.hide();
                }
                if (this.weaponCharges) {
                    this.weaponCharges.reset();
                }

                const distance = Math.floor(this.levelDistance / 10);

                // ⚖️ BALANCE: Enhanced completion bonuses for positive feedback
                let completionBonus = 100 + (this.currentLevel * 20);

                // First-time clear bonus (levels 1-10 only)
                if (this.currentLevel <= 10 && !this.levelStars[this.currentLevel]) {
                    completionBonus += 100;
                }

                // Perfect clear bonus (no damage taken)
                if (this.damageTaken === 0) {
                    completionBonus += 75;
                }

                // Boss victory bonus
                if (this.currentLevel % 5 === 0) {
                    completionBonus += 150;
                }

                const total = this.creditsThisRun + completionBonus;
                
                const stars = this.calculateStars();
                
                document.getElementById('completeDistance').textContent = distance;
                document.getElementById('enemiesKilled').textContent = this.enemiesKilled;
                document.getElementById('completeMaxCombo').textContent = this.maxCombo;
                document.getElementById('completionBonus').textContent = completionBonus;
                document.getElementById('totalEarned').textContent = total;
                document.getElementById('levelStars').textContent = '⭐'.repeat(stars);
                
                if (!this.levelStars[this.currentLevel] || stars > this.levelStars[this.currentLevel]) {
                    this.levelStars[this.currentLevel] = stars;
                }
                
                this.credits += total;
                
                this.achievements.check('firstBlood', this.currentLevel);
                if (this.currentLevel % 5 === 0) {
                    this.achievements.check('bossSlayer', this.currentLevel);
                }
                if (this.damageTaken === 0) {
                    this.achievements.check('untouchable', true);
                }
                this.achievements.check('creditBaron', this.credits);
                this.achievements.check('survivor', this.currentLevel);
                this.achievements.check('legendary', this.ownedShips.length);
                const levelTime = Date.now() - this.levelStartTime;
                this.achievements.check('speedDemon', levelTime);
                
                const newAchs = this.achievements.getNewlyUnlocked();
                const newAchDiv = document.getElementById('newAchievements');
                if (newAchs.length > 0) {
                    newAchDiv.innerHTML = '<p style="color: #ffd700; margin: 20px 0;">🎉 NEW ACHIEVEMENTS! 🎉</p>' +
                        newAchs.map(a => `<p style="font-size: clamp(20px, 5vw, 24px);">${a.icon} ${a.name}</p>`).join('');
                } else {
                    newAchDiv.innerHTML = '';
                }
                
                if (this.currentLevel === this.maxUnlockedLevel) {
                    this.maxUnlockedLevel = Math.min(this.maxUnlockedLevel + 1, 48);
                }
                
                this.saveProgress();
                this.updateUI();
                
                // 🎬 Add epic boss-victory styling for boss levels
                setTimeout(() => {
                    const modal = document.querySelector('#levelComplete .modal');
                    if (modal && this.currentLevel % 5 === 0) {
                        modal.classList.add('boss-victory');
                    }
                }, 50);
                
                this.showScreen('levelComplete');
            }
            
            calculateStars() {
                let stars = 1;
                if (this.damageTaken === 0) stars++;
                if (this.maxCombo >= 10) stars++;
                return stars;
            }
            
            pause() {
                if (this.state === 'PLAYING') {
                    this.state = 'PAUSED';
                    this.showScreen('pauseMenu');
                }
            }
            
            resume() {
                if (this.state === 'PAUSED') {
                    this.state = 'PLAYING';
                    this.showScreen('');
                }
            }
            
            showLevelIntro() {
                this.showingIntro = true;
                this.introTimer = 3000;
            }
            
            updateLevelGrid() {
                const grid = document.getElementById('levelGrid');
                grid.innerHTML = '';

                // 🚀 AAA: Extended from 48 to 58 levels for more content
                for (let i = 1; i <= 58; i++) {
                    const btn = document.createElement('div');
                    btn.className = 'level-button';
                    
                    const isBoss = (i % 5 === 0);
                    if (isBoss) btn.classList.add('boss');
                    
                    if (i <= this.maxUnlockedLevel) {
                        const numSpan = document.createElement('span');
                        numSpan.textContent = isBoss ? '👑' : i;
                        btn.appendChild(numSpan);
                        
                        const stars = this.levelStars[i] || 0;
                        if (stars > 0) {
                            const starSpan = document.createElement('div');
                            starSpan.className = 'stars';
                            starSpan.textContent = '⭐'.repeat(stars);
                            btn.appendChild(starSpan);
                        }
                        
                        btn.onclick = () => this.selectLevel(i);
                        
                        if (i === this.selectedLevel) {
                            btn.classList.add('current');
                        }
                    } else {
                        btn.textContent = '🔒';
                        btn.classList.add('locked');
                    }
                    
                    grid.appendChild(btn);
                }
            }
            
            selectLevel(level) {
                this.selectedLevel = level;
                this.updateLevelGrid();
            }
            
            startSelectedLevel() {
                this.startLevel(this.selectedLevel);
            }
            
            startLevel(level) {
                this.currentLevel = level;
                this.state = 'PLAYING';
                this.showScreen('');
                
                this.levelProgress = 0;
                this.levelDistance = 0;
                this.enemiesKilled = 0;
                this.creditsThisRun = 0;
                this.damageTaken = 0;
                this.levelStartTime = Date.now();
                this.enemies = [];
                this.projectiles = [];
                this.enemyProjectiles = [];
                this.particles = [];
                this.weatherParticles = [];
                this.powerUps = [];
                this.floatingTexts = [];
                this.damageFields = []; // 🌈 NEW: Reset damage fields
                this.enemySpawnTimer = 0;
                this.backgroundOffset = 0;
                this.parallaxOffset = 0;
                this.combo = 0;
                this.comboTimer = 0;
                this.maxCombo = 0;
                this.comboDisplayTime = 0;
                this.superMissileReady = false;
                this.bossSpawned = false;
                this.boss = null;
                this.bossWarning = false;
                this.bossWarningTimer = 0;
                this.bossBattleActive = false;
                this.bossBattlePhase = 'NONE';
                this.bossDefeated = false; // 🔥 NEW: Reset boss defeat flag
                this.bossDefeatTimer = 0;  // 🔥 NEW: Reset boss defeat timer
                
                this.currentTheme = getTheme(level);
                
                // 🛡️ Initialize atmosphere systems
                this.initAtmosphere();

                // ⚖️ BALANCE: Increased base HP from 100 to 150 for better survivability
                const maxHP = 150 + (this.upgrades.health * 20);
                this.player = new Player(this.width / 2, this.height - 100, maxHP, this);
                
                this.showLevelIntro();
                this.audio.startMusic(this.currentTheme);
            }
            
            // 🛡️ NEW: Initialize atmospheric systems
            initAtmosphere() {
                // Create weather particles based on theme
                const particleCount = Math.floor(50 * this.currentTheme.weatherIntensity);
                for (let i = 0; i < particleCount; i++) {
                    this.weatherParticles.push(
                        new WeatherParticle(
                            Math.random() * this.width,
                            Math.random() * this.height,
                            this.currentTheme
                        )
                    );
                }
                
                // Initialize fog layer
                this.fogLayer = new FogLayer(this.width, this.height, this.currentTheme);
                
                // Initialize lightning effect for Electric Yellow theme
                if (this.currentTheme.weatherType === 'lightning') {
                    this.lightningEffect = new LightningEffect(this.width, this.height);
                }
            }
            
            retry() {
                this.startLevel(this.currentLevel);
            }
            
            restartLevel() {
                this.startLevel(this.currentLevel);
            }
            
            nextLevel() {
                if (this.currentLevel < this.maxUnlockedLevel) {
                    this.startLevel(this.currentLevel + 1);
                } else {
                    this.showLevelSelect();
                }
            }
            
            exitToMenu() {
                this.showLevelSelect();
            }
            
            updateUpgradeCards() {
                const container = document.getElementById('upgradeContainer');
                container.innerHTML = '';
                
                const upgradeData = [
                    { key: 'armor', name: 'ARMOR', icon: '🛡️', desc: 'Damage Reduction' },
                    { key: 'firepower', name: 'FIREPOWER', icon: '🔥', desc: 'Bullet Damage' },
                    { key: 'attackSpeed', name: 'REFLEX', icon: '⚡', desc: 'Fire Rate' },
                    { key: 'health', name: 'BIO-REGEN', icon: '❤️', desc: 'Max Health' }
                ];
                
                upgradeData.forEach(upgrade => {
                    const level = this.upgrades[upgrade.key];
                    const cost = this.getUpgradeCost(level);
                    const maxLevel = 10;
                    
                    const card = document.createElement('div');
                    card.className = 'upgrade-card';
                    card.innerHTML = `
                        <div class="upgrade-icon">${upgrade.icon}</div>
                        <h3>${upgrade.name}</h3>
                        <p style="font-size: clamp(11px, 2.8vw, 12px); color: #888;">${upgrade.desc}</p>
                        <div class="upgrade-level">LVL ${level}</div>
                        <div class="upgrade-cost">${cost} 💎</div>
                        <button class="button" 
                                onclick="game.purchaseUpgrade('${upgrade.key}')"
                                ${this.credits < cost || level >= maxLevel ? 'disabled' : ''}>
                            ${level >= maxLevel ? 'MAX' : 'UPGRADE'}
                        </button>
                    `;
                    container.appendChild(card);
                });
            }
            
            updateShipCards() {
                const container = document.getElementById('shipContainer');
                container.innerHTML = '';
                
                Object.values(SHIP_TYPES).forEach(ship => {
                    const owned = this.ownedShips.includes(ship.id);
                    const selected = this.currentShip === ship.id;
                    
                    const card = document.createElement('div');
                    card.className = 'ship-card' + (selected ? ' selected' : '') + (ship.legendary ? ' legendary' : '');
                    
                    let abilityHTML = '';
                    if (ship.ability) {
                        abilityHTML = `<div class="ship-ability-badge">${ship.ability.icon} ${ship.ability.name}</div>
                                      <p style="font-size: clamp(9px, 2.2vw, 10px); color: #aaa; margin: 4px 0;">${ship.ability.desc}</p>`;
                    }
                    
                    card.innerHTML = `
                        <div class="ship-icon">${ship.icon}</div>
                        <h3>${ship.name}</h3>
                        ${abilityHTML}
                        <p style="font-size: clamp(11px, 2.8vw, 12px); color: #888;">${ship.desc}</p>
                        <div class="ship-preview">
                            Speed: ${'▰'.repeat(Math.min(3, Math.floor(ship.speed * 3)))}${'▱'.repeat(Math.max(0, 3 - Math.min(3, Math.floor(ship.speed * 3))))}<br>
                            Size: ${'▰'.repeat(Math.min(3, Math.floor(ship.size * 3)))}${'▱'.repeat(Math.max(0, 3 - Math.min(3, Math.floor(ship.size * 3))))}
                        </div>
                        ${owned ? 
                            `<button class="button" onclick="game.selectShip('${ship.id}')" ${selected ? 'disabled' : ''}>
                                ${selected ? 'EQUIPPED' : 'SELECT'}
                            </button>` :
                            `<div class="ship-cost">${ship.cost} 💎</div>
                            <button class="button" onclick="game.purchaseShip('${ship.id}')" ${this.credits < ship.cost ? 'disabled' : ''}>
                                PURCHASE
                            </button>`
                        }
                    `;
                    container.appendChild(card);
                });
            }
            
            getUpgradeCost(currentLevel) {
                if (currentLevel >= 10) return 0;

                // ⚖️ BALANCE: Adaptive cost curve - cheaper early upgrades for positive feedback loop
                // Levels 0-2: 40% discount (45 credits instead of 75)
                // Levels 3-5: 20% discount (60 credits)
                // Levels 6+: Full price (75 credits)
                let baseCost = 75;
                if (currentLevel <= 2) {
                    baseCost = 45;  // 40% cheaper
                } else if (currentLevel <= 5) {
                    baseCost = 60;  // 20% cheaper
                }

                return baseCost * Math.pow(2, currentLevel);
            }
            
            purchaseUpgrade(upgradeKey) {
                const level = this.upgrades[upgradeKey];
                const cost = this.getUpgradeCost(level);
                
                if (this.credits >= cost && level < 10) {
                    this.credits -= cost;
                    this.upgrades[upgradeKey]++;
                    this.saveProgress();
                    this.updateUpgradeCards();
                    this.updateUI();
                    this.audio.playUpgrade();
                }
            }
            
            purchaseShip(shipId) {
                const ship = SHIP_TYPES[shipId];
                if (this.credits >= ship.cost && !this.ownedShips.includes(shipId)) {
                    this.credits -= ship.cost;
                    this.ownedShips.push(shipId);
                    this.currentShip = shipId;
                    this.saveProgress();
                    this.updateShipCards();
                    this.updateUI();
                    this.audio.playUpgrade();
                    this.achievements.check('legendary', this.ownedShips.length);
                }
            }
            
            selectShip(shipId) {
                if (this.ownedShips.includes(shipId)) {
                    this.currentShip = shipId;
                    this.saveProgress();
                    this.updateShipCards();
                }
            }
            
            updateAchievementsMini() {
                const container = document.getElementById('achievementsMini');
                container.innerHTML = '';
                
                this.achievements.getAll().forEach(ach => {
                    const span = document.createElement('span');
                    span.className = 'achievement';
                    span.textContent = ach.icon;
                    span.title = ach.name;
                    if (ach.unlocked) {
                        span.classList.add('unlocked');
                    }
                    container.appendChild(span);
                });
            }
            
            updateAchievementsList() {
                const list = document.getElementById('achievementsList');
                list.innerHTML = '';
                
                this.achievements.getAll().forEach(ach => {
                    const div = document.createElement('div');
                    div.style.cssText = 'padding: 15px; margin: 10px 0; background: rgba(0,255,255,0.1); border-radius: 8px; border: 1px solid rgba(0,255,255,0.3);';
                    div.innerHTML = `
                        <span style="font-size: clamp(28px, 6vw, 32px); ${ach.unlocked ? '' : 'filter: grayscale(100%); opacity: 0.3;'}">${ach.icon}</span>
                        <strong style="margin-left: 15px; color: ${ach.unlocked ? '#00ffff' : '#666'};">${ach.name}</strong>
                        <p style="margin-top: 5px; font-size: clamp(12px, 3vw, 14px); color: ${ach.unlocked ? '#fff' : '#666'};">${ach.desc}</p>
                        ${ach.unlocked ? '<p style="color: #00ff00; margin-top: 5px; font-size: clamp(12px, 3vw, 14px);">✓ UNLOCKED</p>' : ''}
                    `;
                    list.appendChild(div);
                });
            }
            
            gameLoop(timestamp = 0) {
                requestAnimationFrame((t) => this.gameLoop(t));

                try {
                    let deltaTime = timestamp - this.lastTime;
                    this.lastTime = timestamp;
                    if (deltaTime > 100) deltaTime = 16;

                    if (this.hitStop > 0) {
                        this.hitStop -= deltaTime;
                        if (this.hitStop <= 0) {
                            this.hitStop = 0;
                        } else {
                            deltaTime = 0;
                        }
                    }

                    deltaTime *= this.slowMotion;
                    deltaTime *= this.timeScale; // 🔫 Apply weapon slow-motion effects

                    if (this.state === 'PLAYING') {
                        this.update(deltaTime);
                    }

                    this.render();
                } catch (error) {
                    // 🐛 v0.1.3: Error handling to prevent game crashes
                    console.error('Game loop error:', error);
                    // Attempt to recover by clearing potentially problematic state
                    if (this.activeWeapons && this.activeWeapons.length > 0) {
                        console.warn('Clearing active weapons due to error');
                        this.activeWeapons.length = 0;
                    }
                    // Continue game loop despite error
                }
            }
            
            update(deltaTime) {
                if (this.showingIntro) {
                    this.introTimer -= deltaTime;
                    if (this.introTimer <= 0) {
                        this.showingIntro = false;
                    }
                    return;
                }
                
                if (this.bossWarning) {
                    this.bossWarningTimer -= deltaTime;
                    if (this.bossWarningTimer <= 0) {
                        this.bossWarning = false;
                    }
                }
                
                // 🔥 NEW: Handle boss defeat sequence timer
                if (this.bossDefeated) {
                    this.bossDefeatTimer -= deltaTime;
                    if (this.bossDefeatTimer <= 0) {
                        this.bossDefeated = false;
                        // Show improved level complete screen
                        this.showLevelComplete();
                    }
                    // Don't update game logic during boss defeat sequence
                    return;
                }
                
                this.audio.updateCombatIntensity(this.enemies.length, this.combo, this.levelProgress, this.bossBattleActive);
                
                if (this.slowMotionTimer > 0) {
                    this.slowMotionTimer -= deltaTime;
                    if (this.slowMotionTimer <= 0) {
                        this.slowMotion = 1;
                    }
                }
                
                if (this.flashIntensity > 0) {
                    this.flashIntensity *= 0.9;
                }
                
                if (this.screenShake.intensity > 0) {
                    this.screenShake.intensity *= 0.9;
                    this.screenShake.x = (Math.random() - 0.5) * this.screenShake.intensity;
                    this.screenShake.y = (Math.random() - 0.5) * this.screenShake.intensity;
                    if (this.screenShake.intensity < 0.1) {
                        this.screenShake.intensity = 0;
                        this.screenShake.x = 0;
                        this.screenShake.y = 0;
                    }
                }
                
                if (this.combo > 0) {
                    this.comboTimer -= deltaTime;
                    if (this.comboTimer <= 0) {
                        this.combo = 0;
                        this.superMissileReady = false;
                        this.audio.resetComboTier(); // 🎵 Reset tier tracking
                    }
                }
                
                if (this.comboDisplayTime > 0) {
                    this.comboDisplayTime -= deltaTime;
                }
                
                // 🛡️ Update atmosphere
                if (!this.bossBattleActive) {
                    this.backgroundOffset += 3;
                    this.parallaxOffset += 3;
                    if (this.backgroundOffset > this.height) {
                        this.backgroundOffset = 0;
                    }
                }
                
                // Update weather particles (skip during intro, boss warnings, and victory to save CPU)
                if (!this.showingIntro && !this.bossWarning) {
                    this.weatherParticles.forEach(p => p.update(deltaTime, this.height, this.width));
                }
                
                // Update fog
                if (this.fogLayer) {
                    this.fogLayer.update(deltaTime);
                }
                
                // Update lightning
                if (this.lightningEffect) {
                    this.lightningEffect.trigger();
                    this.lightningEffect.update(deltaTime);
                }
                
                if (this.player) {
                    this.player.update(deltaTime);
                }
                
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    this.projectiles[i].update(deltaTime);
                    if (this.projectiles[i].y < -10 || this.projectiles[i].remove) {
                        this.projectiles.splice(i, 1);
                    }
                }
                
                for (let i = this.enemyProjectiles.length - 1; i >= 0; i--) {
                    this.enemyProjectiles[i].update(deltaTime);
                    
                    if (this.player && this.enemyProjectiles[i].lane === this.player.lane &&
                        this.enemyProjectiles[i].y > this.player.y - 30 &&
                        this.enemyProjectiles[i].y < this.player.y + 30 &&
                        !this.player.invincible) {
                        this.player.takeDamage(10);
                        this.enemyProjectiles.splice(i, 1);
                        continue;
                    }
                    
                    if (this.enemyProjectiles[i].y > this.height + 10) {
                        this.enemyProjectiles.splice(i, 1);
                    }
                }
                
                for (let i = this.powerUps.length - 1; i >= 0; i--) {
                    this.powerUps[i].update(deltaTime);
                    
                    if (this.player && this.powerUps[i].lane === this.player.lane &&
                        Math.abs(this.powerUps[i].y - this.player.y) < 40) {
                        
                        // 🛡️ NEW: Handle shield powerup separately
                        if (this.powerUps[i].type === 'shield') {
                            this.player.shields++;
                            this.createFloatingText(this.player.x, this.player.y - 40, '+1 🛡️', '#00ccff');
                            this.createParticles(this.player.x, this.player.y, 15, '#00ccff');
                        } else {
                            // Weapon powerups (electric, fire, fireworks)
                            this.player.activatePowerUp(this.powerUps[i].type);
                        }
                        
                        this.powerUps.splice(i, 1);
                        this.audio.playPowerUp();
                        this.achievements.usedPowerUp(this.powerUps[i]?.type);
                        continue;
                    }
                    
                    if (this.powerUps[i].y > this.height + 50) {
                        this.powerUps.splice(i, 1);
                    }
                }
                
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    this.enemies[i].update(deltaTime);
                    
                    if (this.enemies[i].type === 'turret' && this.enemies[i].canShoot()) {
                        this.enemyProjectiles.push(
                            new EnemyProjectile(this.enemies[i].x, this.enemies[i].y, this.enemies[i].lane, this)
                        );
                    }
                    
                    if (this.enemies[i].isBoss && this.enemies[i].isLocked) {
                        continue;
                    }
                    
                    if (this.enemies[i].y > this.player.y - 30 && 
                        this.enemies[i].lane === this.player.lane &&
                        !this.player.invincible) {
                        this.player.takeDamage(this.enemies[i].contactDamage);
                        this.enemies[i].destroy();
                        this.enemies.splice(i, 1);
                        continue;
                    }
                    
                    if (this.enemies[i].y > this.height + 50) {
                        // ☠▯ ULTIMATE: Enemy Pass Penalty - Player loses 5 HP when enemy escapes!
                        if (this.player && !this.enemies[i].passedPenaltyApplied && !this.enemies[i].isBoss) {
                            this.player.hp -= 5; // Changed from -1 to -5 HP
                            this.damageTaken += 5;
                            
                            // Red flash effect
                            this.flashIntensity = 0.7; // Stronger flash for bigger penalty
                            
                            // Floating text at player position
                            this.createFloatingText(this.player.x, this.player.y - 40, '-5 HP MISS! ☠▯', '#ff0033');
                            
                            // Stronger screen shake for feedback
                            this.addScreenShake(8);
                            
                            // Audio feedback
                            this.audio.playDamage();
                            
                            // Red particles at player
                            this.createParticles(this.player.x, this.player.y, 10, '#ff0033');
                        }
                        
                        this.enemies.splice(i, 1);
                    }
                }
                
                this.checkCollisions();
                
                if (!this.bossSpawned || (this.boss && this.boss.hp <= 0)) {
                    this.spawnEnemies(deltaTime);
                }
                
                if (!this.bossSpawned && this.levelProgress >= 0.95) {
                    this.spawnBoss();
                }
                
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    this.particles[i].update(deltaTime);
                    if (this.particles[i].life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
                
                // 🌈 NEW: Update damage fields
                for (let i = this.damageFields.length - 1; i >= 0; i--) {
                    this.damageFields[i].update(deltaTime);
                    if (this.damageFields[i].life <= 0) {
                        this.damageFields.splice(i, 1);
                    }
                }
                
                for (let i = this.floatingTexts.length - 1; i >= 0; i--) {
                    this.floatingTexts[i].update(deltaTime);
                    if (this.floatingTexts[i].life <= 0) {
                        this.floatingTexts.splice(i, 1);
                    }
                }

                // 🔫 Update weapon systems
                if (this.weaponCharges) {
                    this.weaponCharges.update(deltaTime);
                }
                if (this.weaponWheel) {
                    this.weaponWheel.update(deltaTime);
                }

                // 🔫 Update active weapons
                for (let i = this.activeWeapons.length - 1; i >= 0; i--) {
                    this.activeWeapons[i].update(deltaTime);
                    if (this.activeWeapons[i].remove) {
                        this.activeWeapons.splice(i, 1);
                    }
                }

                if (!this.bossBattleActive) {
                    this.levelDistance += 3;
                }
                // 🏁 LEVEL PROGRESSION - Adjust level length formula
                const targetDistance = 12000 + (this.currentLevel * 2000);
                this.levelProgress = Math.min(this.levelDistance / targetDistance, 1);
                
                if (this.levelProgress >= 1 && (!this.boss || this.boss.hp <= 0) && !this.bossDefeated) {
                    // 🔥 FIXED: Don't immediately show level complete if we just defeated a boss
                    // The boss defeat sequence will handle showing level complete after delay
                    if (!this.bossSpawned || this.bossDefeatTimer <= 0) {
                        this.showLevelComplete();
                    }
                }
                
                if (this.player && this.player.hp <= 0) {
                    this.showGameOver();
                }
            }
            
            spawnBoss() {
                this.bossSpawned = true;
                this.bossWarning = true;
                this.bossWarningTimer = 2000;
                this.bossBattlePhase = 'WARNING';
                
                this.enemies = this.enemies.filter(e => e.isBoss);
                this.enemyProjectiles = [];
                
                setTimeout(() => {
                    this.boss = new Boss(1, -150, this.currentLevel, this);
                    this.enemies.push(this.boss);
                    this.createFloatingText(this.width / 2, 200, '☠️ BOSS BATTLE! ☠️', '#ffd700');

                    // 🔫 Show weapon wheel after boss appears
                    if (this.weaponWheel) {
                        setTimeout(() => {
                            this.weaponWheel.show();
                        }, 3000); // Show 3 seconds after boss spawns
                    }
                }, 2000);
            }

            // 🔫 Activate a boss weapon
            activateWeapon(weaponId) {
                if (!this.boss || this.boss.hp <= 0) {
                    console.log('🔫 Cannot use weapon - no boss active');
                    return;
                }

                if (!this.weaponCharges.useCharge(weaponId)) {
                    console.log('🔫 Weapon not ready:', weaponId);
                    return;
                }

                console.log('🔫 ACTIVATING WEAPON:', weaponId);

                switch(weaponId) {
                    case 'stink':
                        // 💣 STINK MISSILE - Launch homing missiles!
                        this.activeWeapons.push(new StinkMissile(this));
                        console.log('💣 Stink Missile activated!');
                        break;
                    case 'freeze':
                        // ❄️ FREEZING TORNADO - Freeze all enemies!
                        this.activeWeapons.push(new FreezingTornado(
                            this.boss.x,
                            this.boss.y,
                            this
                        ));
                        console.log('❄️ Freezing Tornado activated!');
                        break;
                    case 'drone':
                        // 🤖 SUPPORT DRONES - Orbital attack drones!
                        this.activeWeapons.push(new SupportDrone(this));
                        console.log('🤖 Support Drones activated!');
                        break;
                    case 'shock':
                        // ⚡ ELECTRIC SHOCK - Chain lightning attack!
                        this.activeWeapons.push(new ElectricShock(this));
                        console.log('⚡ Electric Shock activated!');
                        break;
                    case 'bomb':
                        // ☢️ ATOMIC BOMB - Ultimate weapon!
                        this.activeWeapons.push(new AtomicBomb(
                            this.boss.x,
                            this.boss.y,
                            this.boss,
                            this
                        ));
                        console.log('☢️ ATOMIC BOMB activated!');
                        break;
                }

                this.audio.playUpgrade(); // Play activation sound
            }

            spawnEnemies(deltaTime) {
                this.enemySpawnTimer += deltaTime;

                // ⚖️ BALANCE: Graduated spawn rate curve for breathing room
                // Levels 1-5: Start at 1400ms (slower, easier to learn)
                // Levels 6-10: Start at 1200ms (moderate)
                // Levels 11+: Normal formula
                let baseSpawnTime = 1000;
                if (this.currentLevel <= 5) {
                    baseSpawnTime = 1400;  // 40% slower for tutorial levels
                } else if (this.currentLevel <= 10) {
                    baseSpawnTime = 1200;  // 20% slower for early game
                }

                let spawnRate = Math.max(baseSpawnTime - (this.currentLevel * 40), 300);
                const progress = this.levelProgress;
                if (progress > 0.7) {
                    spawnRate *= 0.6;
                } else if (progress > 0.4) {
                    spawnRate *= 0.8;
                }
                
                if (this.enemySpawnTimer > spawnRate) {
                    this.enemySpawnTimer = 0;
                    
                    const rand = Math.random();
                    let enemyType;
                    
                    if (rand < 0.6) {
                        enemyType = 'drone';
                    } else if (rand < 0.85) {
                        enemyType = 'turret';
                    } else {
                        enemyType = 'barricade';
                    }

                    const lane = Math.floor(Math.random() * 3);
                    const enemy = new Enemy(lane, -50, enemyType, this.currentLevel, this);

                    // ⚖️ BALANCE: Progressive elite spawning - graduated difficulty curve
                    // Levels 1-5: 0% (learn basics)
                    // Levels 6-10: 5% (introduction)
                    // Levels 11-20: 10% (regular encounters)
                    // Levels 21+: 15% (full challenge)
                    let eliteChance = 0;
                    if (this.currentLevel >= 21) {
                        eliteChance = 0.15;
                    } else if (this.currentLevel >= 11) {
                        eliteChance = 0.10;
                    } else if (this.currentLevel >= 6) {
                        eliteChance = 0.05;
                    }

                    if (Math.random() < eliteChance && !enemy.isBoss) {
                        enemy.isElite = true;
                        enemy.hp *= 2;
                        enemy.maxHp = enemy.hp;
                        enemy.creditValue *= 3;
                        enemy.eliteGlow = 0;
                    }

                    this.enemies.push(enemy);
                }
            }
            
            checkCollisions() {
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const proj = this.projectiles[i];
                    if (proj.isSuperMissile) continue;
                    
                    for (let j = this.enemies.length - 1; j >= 0; j--) {
                        const enemy = this.enemies[j];
                        
                        let hitRange = 20;
                        if (proj.type === 'fireworks') hitRange = 60;
                        
                        const inLane = (proj.type === 'electric') ? 
                            Math.abs(proj.lane - enemy.lane) <= 1 : 
                            proj.lane === enemy.lane;
                        
                        if (inLane && proj.y < enemy.y + enemy.height && proj.y > enemy.y - 10) {
                            // ⚖️ BALANCE v0.1.2: Increased base damage from 10 to 12
                            let damage = 12 + (this.upgrades.firepower * 2.5);

                            if (proj.type === 'electric') damage *= 1.5;
                            if (proj.type === 'fire') damage *= 1.3;
                            if (proj.type === 'fireworks') damage *= 2;

                            // 🎯 AAA: Use ship's critical hit chance instead of fixed 10%
                            const critChance = this.player.ship.critChance || 0.10;
                            if (Math.random() < critChance) {
                                damage *= 2;
                                this.createFloatingText(enemy.x, enemy.y, 'CRIT!', '#ffff00');
                                this.hitStop = 30;
                            }

                            // 🛡️ Safety check before calling takeDamage
                            if (enemy && typeof enemy.takeDamage === 'function') {
                                enemy.takeDamage(damage);
                                // 🚀 AAA: Enhanced hit markers with size based on damage
                                const isCrit = Math.floor(damage) > (12 + (this.upgrades.firepower * 2.5)) * 1.5;
                                const hitColor = isCrit ? '#ffff00' : '#ff0033';
                                this.createFloatingText(enemy.x, enemy.y, '-' + Math.floor(damage), hitColor);

                                // 🚀 AAA: Hit marker visual feedback
                                if (isCrit) {
                                    this.createParticles(enemy.x, enemy.y, 15, '#ffff00');
                                } else {
                                    this.createParticles(enemy.x, enemy.y, 8, '#ff6600');
                                }
                            }

                            if (proj.type !== 'electric') {
                                this.projectiles.splice(i, 1);
                            }
                            
                            if (enemy && enemy.hp <= 0) {
                                this.handleEnemyDestroyed(enemy, j);
                            } else {
                                this.audio.playHit();
                                this.addScreenShake(1);
                            }
                            
                            break;
                        }
                    }
                }
            }
            
            handleEnemyDestroyed(enemy, index) {
                this.enemiesKilled++;

                // ⚖️ BALANCE: Early level credit bonus for better economy pacing
                // Levels 1-10: +50% credits to match increased costs
                let creditMultiplier = 1.0;
                if (this.currentLevel <= 10) {
                    creditMultiplier = 1.5;
                }

                const earnedCredits = Math.floor(enemy.creditValue * creditMultiplier);
                this.creditsThisRun += earnedCredits;
                
                this.combo++;

                // ⚖️ BALANCE: Adaptive combo timer - easier in early levels for interesting gameplay
                // Levels 1-5: 2000ms (very forgiving, learn combos)
                // Levels 6-10: 1600ms (moderate)
                // Levels 11+: 1200ms (challenging, original difficulty)
                let comboWindow = 1200;
                if (this.currentLevel <= 5) {
                    comboWindow = 2000;  // 67% longer window for tutorial levels
                } else if (this.currentLevel <= 10) {
                    comboWindow = 1600;  // 33% longer for early game
                }

                this.comboTimer = comboWindow;

                // 🔫 Check weapon unlock milestones
                if (this.weaponCharges) {
                    this.weaponCharges.checkComboMilestones(this.combo);
                }

                if (this.combo > this.maxCombo) {
                    this.maxCombo = this.combo;
                }
                
                // 💚 NEW: Lifesteal every 5 combos
                if (this.combo % 5 === 0 && this.combo > 0) {
                    const healAmount = 10;
                    const oldHp = this.player.hp;
                    this.player.hp = Math.min(this.player.maxHp, this.player.hp + healAmount);
                    const actualHeal = this.player.hp - oldHp;
                    
                    if (actualHeal > 0) {
                        this.createFloatingText(this.player.x, this.player.y - 60, 'LIFESTEAL +' + Math.floor(actualHeal) + ' 💚', '#00ff00');
                        this.createParticles(this.player.x, this.player.y, 20, '#00ff00');
                        this.audio.speakLifesteal(); // 🔊 NEW: Voice announcement
                    }
                }
                
                if (this.combo >= 2) {
                    this.comboDisplayTime = 1000;
                    this.audio.playCombo();
                    this.audio.speakCombo(this.combo); // 🎵 Pass combo count for tiered announcements
                }
                
                // 🚀 ULTIMATE: Escalating Combo System with level-scaled thresholds
                // 🎮 v0.1.3: Early levels (1-5) have easier combo requirements
                const isEarlyLevel = this.currentLevel <= 5;
                const ultimateThreshold = isEarlyLevel ? 18 : 25;
                const orbitalThreshold = isEarlyLevel ? 12 : 18;
                const plasmaThreshold = isEarlyLevel ? 8 : 12;
                const superThreshold = isEarlyLevel ? 5 : 7;

                if (this.combo >= ultimateThreshold && this.combo % 5 === 0) {
                    // 🌈 Ultimate Annihilation (Combo 18+ for levels 1-5, 25+ for levels 6+)
                    this.fireUltimateAnnihilation();
                } else if (this.combo === orbitalThreshold) {
                    // ⚡ Orbital Strike (Combo 12 for levels 1-5, 18 for levels 6+)
                    this.fireOrbitalStrike();
                } else if (this.combo === plasmaThreshold) {
                    // 💜 Plasma Wave (Combo 8 for levels 1-5, 12 for levels 6+)
                    this.firePlasmaWave();
                } else if (this.combo === superThreshold) {
                    // 🚀 Super Missile (Combo 5 for levels 1-5, 7 for levels 6+)
                    this.superMissileReady = true;
                    this.fireSuperMissile();
                }
                
                this.achievements.check('comboMaster', this.combo);

                // 💰 AAA: Reduced combo multiplier from 0.5 to 0.2 (60% nerf for better balance)
                const bonusCredits = enemy.creditValue * (this.combo - 1) * 0.2;
                if (bonusCredits > 0) {
                    this.creditsThisRun += Math.floor(bonusCredits);
                    this.createFloatingText(enemy.x, enemy.y - 20, '+' + Math.floor(bonusCredits) + '💎', '#ffd700');
                }
                
                this.createExplosion(enemy.x, enemy.y, enemy.size);
                
                if (Math.random() < 0.1 && !enemy.isBoss) {
                    const types = ['electric', 'fire', 'fireworks', 'shield']; // 🛡️ NEW: Added shield
                    const type = types[Math.floor(Math.random() * types.length)];
                    this.powerUps.push(new PowerUp(enemy.lane, enemy.y, type, this));
                }
                
                this.enemies.splice(index, 1);
                this.audio.playExplosion();
                
                if (enemy.size > 50) {
                    this.addScreenShake(10);
                } else {
                    this.addScreenShake(3);
                }
                
                if (enemy.isBoss) {
                    // 🎬 ULTIMATE: SPECTACULAR 7.5-second boss defeat celebration!
                    this.bossDefeated = true;
                    this.bossDefeatTimer = 7500; // Extended for full victory experience
                    this.bossBattlePhase = 'VICTORY';
                    this.slowMotion = 0.15; // Even slower for maximum dramatic impact
                    this.slowMotionTimer = 7500;
                    this.flashIntensity = 2; // More intense flash
                    this.addScreenShake(40); // Stronger shake
                    
                    // 🧹 CRITICAL: Clear ALL floating texts for clean victory screen
                    this.floatingTexts = [];
                    
                    // 🎵 Epic voice announcement
                    this.audio.speakBossDefeat();
                    
                    // 🎆 MASSIVE continuous particle effects during 5-second victory
                    const rainbowColors = ['#ff0000', '#ff6600', '#ffff00', '#00ff00', '#00ffff', '#0000ff', '#ff00ff', '#ffd700'];
                    
                    // Primary explosion waves (100 particles - optimized for mobile)
                    for (let i = 0; i < 100; i++) {
                        setTimeout(() => {
                            const color = rainbowColors[i % rainbowColors.length];
                            this.createParticles(enemy.x, enemy.y, 20, color); // More particles per burst
                            
                            // Explosion waves - larger and more frequent
                            if (i % 8 === 0) {
                                for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 12) {
                                    const dist = 50 + (i * 2.5);
                                    const px = enemy.x + Math.cos(angle) * dist;
                                    const py = enemy.y + Math.sin(angle) * dist;
                                    this.createParticles(px, py, 12, color);
                                }
                            }
                            
                            // Extra screen shake pulses
                            if (i % 25 === 0) {
                                this.addScreenShake(15);
                            }
                        }, i * 16); // Slightly faster for more dense effect
                    }
                    
                    // 🔥 Secondary explosion rings
                    for (let ring = 0; ring < 8; ring++) {
                        setTimeout(() => {
                            for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 16) {
                                const dist = 80 + (ring * 60);
                                const px = enemy.x + Math.cos(angle) * dist;
                                const py = enemy.y + Math.sin(angle) * dist;
                                this.createParticles(px, py, 8, rainbowColors[ring % rainbowColors.length]);
                            }
                        }, ring * 600);
                    }
                    
                    // 🏆 Trophy/medal shower effect (30 trophies - optimized for mobile)
                    for (let i = 0; i < 30; i++) {
                        setTimeout(() => {
                            const x = 50 + Math.random() * 700;
                            const y = -50 - Math.random() * 150;
                            const trophy = ['🏆', '👑', '⭐', '🎖️', '💥'][Math.floor(Math.random() * 5)];
                            this.createFloatingText(x, y, trophy, '#ffd700');
                        }, i * 80);
                    }
                    
                    // 💰 Mega credit shower (25 credits - optimized for mobile)
                    for (let i = 0; i < 25; i++) {
                        setTimeout(() => {
                            const x = 100 + Math.random() * 600;
                            const credits = Math.floor(20 + Math.random() * 50); // More credits!
                            this.creditsThisRun += credits;
                            this.createFloatingText(x, 80 + Math.random() * 120, '+' + credits + '💎', '#ffd700');
                        }, i * 100);
                    }
                    
                    // ⚡ Lightning flashes throughout
                    for (let i = 0; i < 10; i++) {
                        setTimeout(() => {
                            this.flashIntensity = 1.5;
                        }, i * 500);
                    }
                    
                    // 🎬 Store boss victory data for cinematic render
                    this.bossVictoryData = {
                        x: this.width / 2,
                        y: this.height / 2,
                        startTime: Date.now(),
                        level: this.currentLevel
                    };
                    
                    // 🚀 CRITICAL: Don't clear victory data until right before transition
                    // This keeps the victory screen visible the entire time
                    setTimeout(() => {
                        this.bossBattleActive = false;
                        this.bossBattlePhase = 'NONE';
                        // Keep bossVictoryData until level complete shows
                    }, 3900); // Clear 100ms before transition for smooth handoff
                }
            }
            
            fireSuperMissile() {
                this.superMissileReady = false;
                
                const missile = new SuperMissile(this.player.x, this.player.y - 50, this);
                this.projectiles.push(missile);
                
                this.audio.playSuperMissile();
                this.addScreenShake(15);
                this.createFloatingText(this.width / 2, this.height / 2, '🚀 SUPER MISSILE! 🚀', '#ffff00');
                
                this.hitStop = 30;
                
                setTimeout(() => {
                    if (this.boss && this.boss.hp > 0) {
                        this.spawnBossReinforcements();
                    }
                }, 1000);
            }
            
            // 💜 NEW: Combo 10 - Plasma Wave
            firePlasmaWave() {
                this.addScreenShake(20);
                this.flashIntensity = 0.8;
                this.hitStop = 40;
                this.audio.playSuperMissile(); // Reuse sound for now
                
                this.createFloatingText(this.width / 2, this.height / 2, '💜 PLASMA WAVE! 💜', '#ff00ff');
                
                // Create massive purple/magenta explosion particles
                for (let i = 0; i < 150; i++) {
                    this.createParticles(this.width / 2, this.height / 2, 1, '#ff00ff');
                }
                
                // Deal 400 damage and stun all enemies for 1 second
                for (let j = this.enemies.length - 1; j >= 0; j--) {
                    const enemy = this.enemies[j];
                    
                    // 🛡️ Safety check - skip if enemy is undefined
                    if (!enemy || typeof enemy.takeDamage !== 'function') continue;
                    
                    let plasmaDamage = 400;
                    
                    // 🔥 FIXED: Bosses take only 30% damage from special attacks
                    if (enemy.isBoss) {
                        plasmaDamage *= 0.3;
                    }
                    
                    enemy.takeDamage(plasmaDamage);
                    
                    // Stun effect (only non-bosses get stunned)
                    if (!enemy.isBoss) {
                        enemy.stunned = true;
                        enemy.stunTimer = 1000; // 1 second stun
                    }
                    
                    this.createFloatingText(enemy.x, enemy.y - 30, '🔥 -' + Math.floor(plasmaDamage), '#ff00ff');
                    this.createParticles(enemy.x, enemy.y, 15, '#ff00ff');
                    
                    // 🔥 FIXED: Don't auto-destroy bosses, let normal game loop handle it
                    if (enemy.hp <= 0 && !enemy.isBoss) {
                        this.handleEnemyDestroyed(enemy, j);
                    }
                }
            }
            
            // ⚡ NEW: Combo 15 - Orbital Strike
            fireOrbitalStrike() {
                this.addScreenShake(25);
                this.flashIntensity = 1;
                this.hitStop = 50;
                this.audio.playSuperMissile();
                
                this.createFloatingText(this.width / 2, this.height / 2, '⚡ ORBITAL STRIKE! ⚡', '#00ffff');
                
                // Create blue/white lightning particles
                for (let i = 0; i < 200; i++) {
                    const color = i % 2 === 0 ? '#00ffff' : '#ffffff';
                    this.createParticles(this.width / 2, 100, 1, color);
                }
                
                // Deal 600 damage with chain lightning effect
                let enemiesHit = [...this.enemies];
                
                for (let j = enemiesHit.length - 1; j >= 0; j--) {
                    const enemy = enemiesHit[j];
                    
                    // 🛡️ Safety check - skip if enemy is undefined
                    if (!enemy || typeof enemy.takeDamage !== 'function') continue;
                    
                    let strikeDamage = 600;
                    
                    // 🔥 FIXED: Bosses take only 30% damage from special attacks
                    if (enemy.isBoss) {
                        strikeDamage *= 0.3;
                    }
                    
                    enemy.takeDamage(strikeDamage);
                    
                    this.createFloatingText(enemy.x, enemy.y - 30, '⚡ -' + Math.floor(strikeDamage), '#00ffff');
                    
                    // Chain lightning visual effect
                    for (let k = 0; k < 5; k++) {
                        setTimeout(() => {
                            this.createParticles(enemy.x, enemy.y, 10, '#00ffff');
                        }, k * 50);
                    }
                    
                    // 🔥 FIXED: Don't auto-destroy bosses, let normal game loop handle it
                    if (enemy && enemy.hp <= 0 && !enemy.isBoss) {
                        const index = this.enemies.indexOf(enemy);
                        if (index > -1) {
                            this.handleEnemyDestroyed(enemy, index);
                        }
                    }
                }
            }
            
            // 🌈 NEW: Combo 20+ - Ultimate Annihilation
            fireUltimateAnnihilation() {
                this.addScreenShake(35);
                this.flashIntensity = 1.5;
                this.hitStop = 60;
                this.slowMotion = 0.5;
                this.slowMotionTimer = 1000;
                this.audio.playSuperMissile();
                
                this.createFloatingText(this.width / 2, this.height / 2, '🌈 ULTIMATE ANNIHILATION! 🌈', '#ffffff');
                
                // Create rainbow prismatic explosion
                const rainbowColors = ['#ff0000', '#ff6600', '#ffff00', '#00ff00', '#00ffff', '#0000ff', '#ff00ff'];
                for (let i = 0; i < 300; i++) {
                    const color = rainbowColors[i % rainbowColors.length];
                    this.createParticles(this.width / 2, this.height / 2, 1, color);
                }
                
                // Deal 1000 damage to all enemies
                for (let j = this.enemies.length - 1; j >= 0; j--) {
                    const enemy = this.enemies[j];
                    
                    // 🛡️ Safety check - skip if enemy is undefined
                    if (!enemy || typeof enemy.takeDamage !== 'function') continue;
                    
                    let annihilationDamage = 1000;
                    
                    // 🔥 FIXED: Bosses take only 30% damage from special attacks
                    if (enemy.isBoss) {
                        annihilationDamage *= 0.3;
                    }
                    
                    enemy.takeDamage(annihilationDamage);
                    
                    this.createFloatingText(enemy.x, enemy.y - 30, '🌈 -' + Math.floor(annihilationDamage), '#ffffff');
                    
                    // Rainbow particles
                    for (let c = 0; c < 20; c++) {
                        this.createParticles(enemy.x, enemy.y, 1, rainbowColors[c % rainbowColors.length]);
                    }
                    
                    // 🔥 FIXED: Don't auto-destroy bosses, let normal game loop handle it
                    if (enemy && enemy.hp <= 0 && !enemy.isBoss) {
                        this.handleEnemyDestroyed(enemy, j);
                    }
                }
                
                // Create lingering damage field
                const damageField = new DamageField(this.width / 2, this.height / 2, this);
                this.damageFields.push(damageField);
            }
            
            spawnBossReinforcements() {
                for (let i = 0; i < 10; i++) {
                    setTimeout(() => {
                        const lane = Math.floor(Math.random() * 3);
                        this.enemies.push(new Enemy(lane, -50, 'drone', this.currentLevel, this));
                    }, i * 100);
                }
                this.createFloatingText(this.width / 2, 200, '☠▯ REINFORCEMENTS! ☠▯', '#ff0000');
            }
            
            addScreenShake(intensity) {
                this.screenShake.intensity = Math.max(this.screenShake.intensity, intensity);
            }
            
            createParticles(x, y, count, color) {
                for (let i = 0; i < count; i++) {
                    this.particles.push(new Particle(x, y, color));
                }
            }
            
            createExplosion(x, y, size) {
                const count = Math.floor(size / 5);
                for (let i = 0; i < count; i++) {
                    this.particles.push(new Particle(x, y, '#ff6600', true));
                }
            }
            
            createFloatingText(x, y, text, color) {
                this.floatingTexts.push(new FloatingText(x, y, text, color));
            }
            
            render() {
                this.ctx.save();
                this.ctx.translate(this.screenShake.x, this.screenShake.y);
                
                this.ctx.fillStyle = this.currentTheme.bg;
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                if (this.state === 'PLAYING' || this.state === 'PAUSED') {
                    this.renderGame();
                }
                
                if (this.flashIntensity > 0) {
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${this.flashIntensity * 0.5})`;
                    this.ctx.fillRect(0, 0, this.width, this.height);
                }
                
                this.ctx.restore();
                
                if (this.showingIntro) {
                    this.renderLevelIntro();
                }
                
                if (this.bossWarning) {
                    this.renderBossWarning();
                }
                
                // 🎬 ULTIMATE: Render modern boss victory cinematic
                if (this.bossDefeated && this.bossVictoryData) {
                    this.renderBossVictoryCinematic();
                }

                // 🔫 Render weapon wheel (on top of everything)
                if (this.weaponWheel) {
                    this.weaponWheel.render(this.ctx);
                }
            }
            
            renderGame() {
                this.renderBackground();
                this.renderLanes();
                
                // 🛡️ Render fog layers
                if (this.fogLayer) {
                    this.fogLayer.render(this.ctx);
                }
                
                // 🛡️ Render weather
                this.weatherParticles.forEach(p => p.render(this.ctx));
                
                // 🛡️ Render lightning
                if (this.lightningEffect) {
                    this.lightningEffect.render(this.ctx);
                }
                
                this.enemyProjectiles.forEach(proj => proj.render(this.ctx));
                this.powerUps.forEach(pu => pu.render(this.ctx));
                this.enemies.forEach(enemy => enemy.render(this.ctx));
                
                if (this.player) {
                    this.player.render(this.ctx);
                }
                
                this.projectiles.forEach(proj => proj.render(this.ctx));
                this.particles.forEach(particle => particle.render(this.ctx));
                this.damageFields.forEach(field => field.render(this.ctx)); // 🌈 NEW: Render damage fields
                this.floatingTexts.forEach(text => text.render(this.ctx));

                // 🔫 Render active weapon effects
                this.activeWeapons.forEach(weapon => weapon.render(this.ctx));

                this.renderHUD();
                
                if (this.comboDisplayTime > 0 && this.combo >= 2) {
                    this.renderCombo();
                }
            }
            
            // 🛡️ ENHANCED: Background rendering with parallax
            renderBackground() {
                const theme = this.currentTheme;
                
                // Base gradient
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.height);
                gradient.addColorStop(0, theme.bg);
                gradient.addColorStop(1, this.lightenColor(theme.bg, 20));
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // 🛡️ Parallax layers
                theme.parallaxLayers.forEach((layer, index) => {
                    this.ctx.save();
                    this.ctx.globalAlpha = layer.opacity;
                    this.ctx.fillStyle = layer.color;
                    
                    const offset = (this.parallaxOffset * layer.speed) % 200;
                    for (let i = 0; i < 5; i++) {
                        const x = i * 180;
                        const h = 100 + (i * 30) + (index * 20);
                        this.ctx.fillRect(x, offset - 200 + this.height - h, 150, h);
                        this.ctx.fillRect(x, offset + this.height - h, 150, h);
                    }
                    
                    this.ctx.restore();
                });
                
                // Stars
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                for (let i = 0; i < 50; i++) {
                    const x = (i * 37) % this.width;
                    const y = ((i * 73) + this.backgroundOffset * 0.3) % this.height;
                    this.ctx.fillRect(x, y, 2, 2);
                }
            }
            
            renderLanes() {
                const laneWidth = 200;
                const startX = (this.width - laneWidth * 3) / 2;
                
                this.ctx.strokeStyle = this.hexToRgba(this.currentTheme.primary, 0.5);
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([20, 10]);
                
                for (let i = 0; i <= 3; i++) {
                    const x = startX + (i * laneWidth);
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.height);
                    this.ctx.stroke();
                }
                
                this.ctx.setLineDash([]);
                
                if (this.bossBattleActive) {
                    const pulseIntensity = 0.5 + Math.sin(Date.now() / 200) * 0.3;
                    this.ctx.strokeStyle = this.hexToRgba('#ffd700', pulseIntensity);
                    this.ctx.lineWidth = 4;
                    this.ctx.shadowBlur = 20;
                    this.ctx.shadowColor = '#ffd700';
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, 250);
                    this.ctx.lineTo(this.width, 250);
                    this.ctx.stroke();
                    
                    this.ctx.strokeRect(startX - 5, 0, laneWidth * 3 + 10, this.height);
                    
                    this.ctx.shadowBlur = 0;
                    
                    this.ctx.fillStyle = this.hexToRgba('#ffd700', pulseIntensity);
                    this.ctx.font = 'bold 16px Courier New';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('☠️ BOSS ARENA ☠️', this.width / 2, 270);
                }
            }
            
            renderHUD() {
                const padding = 20;
                
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                this.ctx.fillRect(padding, padding, 40, 40);
                this.ctx.fillRect(padding + 50, padding, 40, 40);
                this.ctx.fillRect(padding + 100, padding, 40, 40);
                
                this.ctx.fillStyle = this.currentTheme.primary;
                this.ctx.font = '24px Courier New';
                this.ctx.fillText('⏸', padding + 10, padding + 30);
                this.ctx.fillText('🔊', padding + 60, padding + 30);
                this.ctx.fillText('🏠', padding + 110, padding + 30);
                
                const barWidth = 400;
                const barHeight = 30;
                const barX = (this.width - barWidth) / 2;
                const barY = padding;
                
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(barX, barY, barWidth, barHeight);
                
                const fillWidth = barWidth * this.levelProgress;
                const gradient = this.ctx.createLinearGradient(barX, 0, barX + barWidth, 0);
                gradient.addColorStop(0, this.currentTheme.primary);
                gradient.addColorStop(1, this.currentTheme.secondary);
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(barX, barY, fillWidth, barHeight);
                
                this.ctx.strokeStyle = this.currentTheme.primary;
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(barX, barY, barWidth, barHeight);
                
                this.ctx.fillStyle = '#fff';
                this.ctx.font = 'bold 14px Courier New';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('LEVEL ' + this.currentLevel, barX + barWidth / 2, barY + 20);
                
                if (this.levelProgress >= 0.95) {
                    this.ctx.fillStyle = '#ffd700';
                    this.ctx.fillText('🎯', barX + barWidth + 20, barY + 20);
                }
                
                this.ctx.textAlign = 'right';
                this.ctx.fillStyle = '#ffd700';
                this.ctx.font = 'bold 24px Courier New';
                this.ctx.fillText(`💎 ${this.creditsThisRun}`, this.width - padding, padding + 25);
                
                // 💀 NEW: Kill counter display
                this.ctx.fillStyle = '#ff0066';
                this.ctx.font = 'bold 20px Courier New';
                this.ctx.shadowBlur = 5;
                this.ctx.shadowColor = '#ff0066';
                this.ctx.fillText(`💀 ${this.enemiesKilled}`, this.width - padding, padding + 50);
                this.ctx.shadowBlur = 0;
                
                if (this.combo >= 2) {
                    this.ctx.fillStyle = this.currentTheme.secondary;
                    this.ctx.font = 'bold 20px Courier New';
                    this.ctx.shadowBlur = 10;
                    this.ctx.shadowColor = this.currentTheme.secondary;
                    this.ctx.fillText(`${this.combo}x COMBO`, this.width - padding, padding + 75);
                    
                    // 🚀 NEW: Show different special attack based on combo level
                    if (this.combo >= 20) {
                        this.ctx.fillStyle = '#ffffff';
                        this.ctx.shadowColor = '#ffffff';
                        this.ctx.fillText('🌈 ULTIMATE!', this.width - padding, padding + 100);
                    } else if (this.combo >= 15) {
                        this.ctx.fillStyle = '#00ffff';
                        this.ctx.shadowColor = '#00ffff';
                        this.ctx.fillText('⚡ ORBITAL!', this.width - padding, padding + 100);
                    } else if (this.combo >= 10) {
                        this.ctx.fillStyle = '#ff00ff';
                        this.ctx.shadowColor = '#ff00ff';
                        this.ctx.fillText('💜 PLASMA!', this.width - padding, padding + 100);
                    } else if (this.combo >= 5) {
                        this.ctx.fillStyle = '#ffff00';
                        this.ctx.shadowColor = '#ffff00';
                        this.ctx.fillText('🚀 READY!', this.width - padding, padding + 100);
                    }
                    this.ctx.shadowBlur = 0;
                }
                
                if (this.player && this.player.currentPowerUp) {
                    const pu = this.player.currentPowerUp;
                    this.ctx.textAlign = 'left';
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(padding, padding + 60, 120, 50);
                    
                    this.ctx.fillStyle = pu.color;
                    this.ctx.font = 'bold 16px Courier New';
                    this.ctx.fillText(pu.icon + ' ' + pu.name, padding + 5, padding + 80);
                    this.ctx.fillText(Math.ceil(pu.remaining) + ' left', padding + 5, padding + 100);
                }
                
                if (this.player && this.player.ship.ability && this.player.abilityCharges !== undefined) {
                    this.ctx.textAlign = 'left';
                    this.ctx.fillStyle = 'rgba(138, 43, 226, 0.7)';
                    this.ctx.fillRect(padding, padding + 120, 120, 50);
                    
                    this.ctx.fillStyle = '#ff00ff';
                    this.ctx.font = 'bold 14px Courier New';
                    this.ctx.fillText(this.player.ship.ability.icon + ' ' + this.player.ship.ability.name.split(' ')[0], padding + 5, padding + 140);
                    
                    if (this.player.abilityCooldown > 0) {
                        const cooldownSec = Math.ceil(this.player.abilityCooldown / 1000);
                        this.ctx.fillStyle = '#ff6600';
                        this.ctx.fillText(`Cooldown: ${cooldownSec}s`, padding + 5, padding + 160);
                    } else if (this.player.abilityCharges !== null) {
                        this.ctx.fillStyle = '#00ff00';
                        this.ctx.fillText(`Charges: ${this.player.abilityCharges}`, padding + 5, padding + 160);
                    } else {
                        this.ctx.fillStyle = '#00ff00';
                        this.ctx.fillText('READY!', padding + 5, padding + 160);
                    }
                }
                
                if (this.player) {
                    this.ctx.textAlign = 'left';
                    
                    const hpPercent = this.player.hp / this.player.maxHp;
                    if (hpPercent > 0.5) {
                        this.ctx.fillStyle = '#00ff88';
                    } else if (hpPercent > 0.25) {
                        this.ctx.fillStyle = '#ffd700';
                    } else {
                        this.ctx.fillStyle = '#ff0033';
                    }
                    
                    this.ctx.font = 'bold 20px Courier New';
                    this.ctx.fillText(`❤️ ${Math.ceil(this.player.hp)}/${this.player.maxHp}`, padding, this.height - padding);
                    
                    const hpBarWidth = 200;
                    const hpBarHeight = 10;
                    const hpBarX = padding;
                    const hpBarY = this.height - padding - 30;
                    
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight);
                    
                    this.ctx.fillStyle = hpPercent > 0.5 ? '#00ff88' : hpPercent > 0.25 ? '#ffd700' : '#ff0033';
                    this.ctx.fillRect(hpBarX, hpBarY, hpBarWidth * hpPercent, hpBarHeight);
                    
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight);

                    // 🚀 AAA: Ship Shield Capacity Bar (new system)
                    if (this.player.maxShieldCapacity > 0) {
                        const shieldBarY = hpBarY - 15;
                        const shieldPercent = this.player.currentShieldCapacity / this.player.maxShieldCapacity;

                        this.ctx.fillStyle = 'rgba(0, 100, 200, 0.3)';
                        this.ctx.fillRect(hpBarX, shieldBarY, hpBarWidth, 8);

                        const shieldGradient = this.ctx.createLinearGradient(hpBarX, 0, hpBarX + hpBarWidth, 0);
                        shieldGradient.addColorStop(0, '#00ddff');
                        shieldGradient.addColorStop(1, '#0088ff');
                        this.ctx.fillStyle = shieldGradient;
                        this.ctx.fillRect(hpBarX, shieldBarY, hpBarWidth * shieldPercent, 8);

                        this.ctx.strokeStyle = '#00ccff';
                        this.ctx.lineWidth = 1;
                        this.ctx.strokeRect(hpBarX, shieldBarY, hpBarWidth, 8);

                        // Shield label
                        this.ctx.fillStyle = '#00ddff';
                        this.ctx.font = 'bold 12px Courier New';
                        this.ctx.fillText(`⚡${Math.floor(this.player.currentShieldCapacity)}%`, hpBarX + hpBarWidth + 10, shieldBarY + 7);
                    }

                    // 🛡️ Power-up Shield display (original system)
                    if (this.player.shields > 0) {
                        this.ctx.fillStyle = '#00ccff';
                        this.ctx.font = 'bold 18px Courier New';
                        this.ctx.shadowBlur = 10;
                        this.ctx.shadowColor = '#00ccff';
                        this.ctx.fillText(`🛡️ ${this.player.shields}`, padding + 210, this.height - padding);
                        this.ctx.shadowBlur = 0;
                    }
                }
                
                if (this.boss && this.boss.hp > 0) {
                    const bossBarY = 100;
                    const bossBarWidth = 600;
                    const bossBarHeight = 30;
                    const bossBarX = (this.width - bossBarWidth) / 2;
                    
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    this.ctx.fillRect(bossBarX, bossBarY, bossBarWidth, bossBarHeight);
                    
                    const bossHpPercent = this.boss.hp / this.boss.maxHp;
                    const gradient2 = this.ctx.createLinearGradient(bossBarX, 0, bossBarX + bossBarWidth, 0);
                    gradient2.addColorStop(0, '#ff0000');
                    gradient2.addColorStop(0.5, '#ff6600');
                    gradient2.addColorStop(1, '#ffaa00');
                    this.ctx.fillStyle = gradient2;
                    this.ctx.fillRect(bossBarX, bossBarY, bossBarWidth * bossHpPercent, bossBarHeight);
                    
                    this.ctx.strokeStyle = '#ffd700';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(bossBarX, bossBarY, bossBarWidth, bossBarHeight);
                    
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = 'bold 18px Courier New';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('👑 BOSS: ' + Math.ceil(this.boss.hp) + ' / ' + this.boss.maxHp, this.width / 2, bossBarY + 20);
                    
                    if (this.boss.isLocked) {
                        this.ctx.fillStyle = '#ff00ff';
                        this.ctx.font = 'bold 14px Courier New';
                        this.ctx.fillText('PHASE ' + this.boss.phase + ' - ' + this.boss.attackPattern, this.width / 2, bossBarY - 10);
                    }
                }
                
                this.ctx.textAlign = 'left';
            }
            
            renderCombo() {
                this.ctx.save();
                this.ctx.textAlign = 'center';
                this.ctx.font = 'bold 60px Courier New';
                
                const alpha = Math.min(this.comboDisplayTime / 500, 1);
                this.ctx.globalAlpha = alpha;
                
                this.ctx.fillStyle = '#ffd700';
                this.ctx.shadowBlur = 30;
                this.ctx.shadowColor = this.currentTheme.secondary;
                
                let text = this.combo + 'x COMBO!';
                if (this.combo >= 5) text = '⚡ ' + text + ' ⚡';
                if (this.combo >= 10) text = '🔥 ULTRA ' + text + ' 🔥';
                
                this.ctx.fillText(text, this.width / 2, this.height / 2);
                
                this.ctx.restore();
            }
            
            renderLevelIntro() {
                const card = document.createElement('div');
                card.className = 'intro-card';
                card.innerHTML = `
                    <h2 style="font-size: clamp(36px, 8vw, 48px); color: ${this.currentTheme.primary}; margin-bottom: 20px;">
                        LEVEL ${this.currentLevel}
                    </h2>
                    <p style="font-size: clamp(18px, 4.5vw, 24px); color: #fff; margin-bottom: 10px;">
                        ${this.currentTheme.name}
                    </p>
                    <p style="font-size: clamp(14px, 3.5vw, 18px); color: #888; margin-bottom: 10px;">
                        Weather: ${this.currentTheme.weatherType.toUpperCase()}
                    </p>
                    <p style="font-size: clamp(12px, 3vw, 16px); color: #888; font-style: italic;">
                        "Navigate the digital wasteland"
                    </p>
                `;
                
                if (!document.querySelector('.intro-card')) {
                    document.getElementById('gameContainer').appendChild(card);
                    setTimeout(() => card.remove(), 3000);
                }
            }
            
            renderBossWarning() {
                const warning = document.createElement('div');
                warning.className = 'warning-text';
                warning.innerHTML = '☠▯ BOSS APPROACHING ☠▯<br><span style="font-size: 0.6em;">PREPARE FOR ARENA BATTLE!</span>';
                
                if (!document.querySelector('.warning-text')) {
                    document.getElementById('gameContainer').appendChild(warning);
                    setTimeout(() => warning.remove(), 2000);
                }
            }
            
            // 🎬 ULTIMATE: Modern cinematic boss victory display
            renderBossVictoryCinematic() {
                const data = this.bossVictoryData;
                if (!data) return;
                
                const elapsed = Date.now() - data.startTime;
                const progress = Math.min(elapsed / 7500, 1); // Extended to 7.5s to match timer
                
                // Dark overlay - STAY SOLID, no pulsing fade
                const overlayAlpha = 0.85; // Keep it dark and solid
                this.ctx.fillStyle = `rgba(0, 0, 0, ${overlayAlpha})`;
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // Animated glow rings expanding from center
                for (let i = 0; i < 5; i++) {
                    const ringProgress = ((elapsed / 500) + i * 0.2) % 1;
                    const radius = ringProgress * 400;
                    const alpha = (1 - ringProgress) * 0.5;
                    
                    this.ctx.strokeStyle = `rgba(255, 215, 0, ${alpha})`;
                    this.ctx.lineWidth = 10 - (ringProgress * 8);
                    this.ctx.shadowBlur = 30;
                    this.ctx.shadowColor = '#ffd700';
                    this.ctx.beginPath();
                    this.ctx.arc(data.x, data.y, radius, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
                this.ctx.shadowBlur = 0;
                
                // Main title with scale animation
                const titleScale = Math.min(progress * 1.5, 1);
                const titleY = data.y - 100;
                
                this.ctx.save();
                this.ctx.translate(data.x, titleY);
                this.ctx.scale(titleScale, titleScale);
                
                // Glowing background for text
                this.ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
                this.ctx.fillRect(-300, -50, 600, 80);
                
                // Border with animated glow
                const borderGlow = 20 + Math.sin(elapsed / 100) * 10;
                this.ctx.strokeStyle = '#ffd700';
                this.ctx.lineWidth = 4;
                this.ctx.shadowBlur = borderGlow;
                this.ctx.shadowColor = '#ffd700';
                this.ctx.strokeRect(-300, -50, 600, 80);
                this.ctx.shadowBlur = 0;
                
                // Main victory text with glitch effect
                this.ctx.font = 'bold 48px Courier New';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                
                // Triple layer text for depth
                this.ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                this.ctx.fillText('☠️ BOSS DEFEATED ☠️', -2, -2);
                this.ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
                this.ctx.fillText('☠️ BOSS DEFEATED ☠️', 2, 2);
                
                // Main text with pulsing glow
                const textGlow = 30 + Math.sin(elapsed / 150) * 20;
                this.ctx.shadowBlur = textGlow;
                this.ctx.shadowColor = '#ffd700';
                this.ctx.fillStyle = '#ffffff';
                this.ctx.fillText('☠️ BOSS DEFEATED ☠️', 0, 0);
                
                this.ctx.restore();
                
                // Subtitle with slide-in animation
                if (progress > 0.3) {
                    const subtitleAlpha = Math.min((progress - 0.3) / 0.3, 1);
                    const subtitleY = data.y - 20;
                    
                    this.ctx.save();
                    this.ctx.globalAlpha = subtitleAlpha;
                    
                    this.ctx.font = 'bold 36px Courier New';
                    this.ctx.textAlign = 'center';
                    this.ctx.shadowBlur = 20;
                    this.ctx.shadowColor = '#00ffff';
                    this.ctx.fillStyle = '#00ffff';
                    this.ctx.fillText('LEVEL ' + data.level + ' COMPLETE!', data.x, subtitleY);
                    
                    this.ctx.restore();
                }
                
                // Combo multiplier display
                if (progress > 0.5 && this.combo >= 2) {
                    const comboAlpha = Math.min((progress - 0.5) / 0.3, 1);
                    const comboY = data.y + 60;
                    
                    this.ctx.save();
                    this.ctx.globalAlpha = comboAlpha;
                    
                    this.ctx.font = 'bold 56px Courier New';
                    this.ctx.textAlign = 'center';
                    
                    // Animated rainbow effect for combo
                    const hue = (elapsed / 20) % 360;
                    this.ctx.shadowBlur = 40;
                    this.ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;
                    this.ctx.fillStyle = `hsl(${hue}, 100%, 60%)`;
                    this.ctx.fillText(this.combo + 'x COMBO!', data.x, comboY);
                    
                    this.ctx.restore();
                }
                
                // Particle starbursts in corners
                if (progress > 0.2) {
                    const corners = [
                        {x: 50, y: 50},
                        {x: this.width - 50, y: 50},
                        {x: 50, y: this.height - 50},
                        {x: this.width - 50, y: this.height - 50}
                    ];
                    
                    corners.forEach((corner, i) => {
                        const cornerProgress = ((elapsed / 100) + i * 0.25) % 1;
                        for (let j = 0; j < 8; j++) {
                            const angle = (j / 8) * Math.PI * 2;
                            const dist = cornerProgress * 80;
                            const x = corner.x + Math.cos(angle) * dist;
                            const y = corner.y + Math.sin(angle) * dist;
                            const alpha = (1 - cornerProgress) * 0.8;
                            
                            this.ctx.fillStyle = `rgba(255, 215, 0, ${alpha})`;
                            this.ctx.fillRect(x - 4, y - 4, 8, 8);
                        }
                    });
                }
                
                // Final "press to continue" hint
                if (progress > 0.8) {
                    const hintAlpha = Math.sin(elapsed / 300) * 0.3 + 0.5;
                    this.ctx.save();
                    this.ctx.globalAlpha = hintAlpha;
                    this.ctx.font = 'bold 18px Courier New';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillStyle = '#888';
                    this.ctx.fillText('Victory complete...', data.x, data.y + 150);
                    this.ctx.restore();
                }
            }
            
            getLaneX(lane) {
                const laneWidth = 200;
                const startX = (this.width - laneWidth * 3) / 2;
                return startX + (lane * laneWidth) + (laneWidth / 2);
            }
            
            toggleSound() {
                this.soundEnabled = this.audio.toggle();
                document.getElementById('soundStatus').textContent = this.soundEnabled ? 'ON' : 'OFF';
            }
            
            updateUI() {
                document.getElementById('creditsDisplay').textContent = this.credits;
            }
            
            saveProgress() {
                const data = {
                    credits: this.credits,
                    maxUnlockedLevel: this.maxUnlockedLevel,
                    upgrades: this.upgrades,
                    currentShip: this.currentShip,
                    ownedShips: this.ownedShips,
                    levelStars: this.levelStars,
                    // 🚀 AAA: Save lifetime stats
                    lifetimeStats: this.lifetimeStats
                };
                localStorage.setItem('lastwar_save', JSON.stringify(data));
            }
            
            loadProgress() {
                const saved = localStorage.getItem('lastwar_save');
                if (saved) {
                    const data = JSON.parse(saved);
                    this.credits = data.credits || 0;
                    this.maxUnlockedLevel = data.maxUnlockedLevel || 1;
                    this.upgrades = data.upgrades || { armor: 0, firepower: 0, attackSpeed: 0, health: 0 };
                    this.currentShip = data.currentShip || 'fighter';
                    this.ownedShips = data.ownedShips || ['fighter'];
                    this.levelStars = data.levelStars || {};
                    // 🚀 AAA: Load lifetime stats
                    if (data.lifetimeStats) {
                        this.lifetimeStats = data.lifetimeStats;
                    }
                } else {
                    // ⚖️ BALANCE: New players get starting credits for power fantasy opening
                    this.credits = 200;
                    // ⚖️ BALANCE: Start with 1 armor upgrade (20% damage reduction)
                    this.upgrades.armor = 1;
                }
            }
            
            hexToRgba(hex, alpha) {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }
            
            lightenColor(hex, percent) {
                const num = parseInt(hex.replace('#', ''), 16);
                const amt = Math.round(2.55 * percent);
                const R = Math.min(255, (num >> 16) + amt);
                const G = Math.min(255, (num >> 8 & 0x00FF) + amt);
                const B = Math.min(255, (num & 0x0000FF) + amt);
                return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
            }
        }
        
        // [PLAYER, ENEMY, BOSS, PROJECTILE CLASSES REMAIN THE SAME - continuing below]
        

        // ═══════════════════════════════════════════════════════════════════════════════
        // 👤 MODULE: PLAYER ENTITY
        // ═══════════════════════════════════════════════════════════════════════════════
        // PURPOSE: Player ship behavior, movement, shooting, abilities
        // SAFE TO MODIFY: Player base stats (search: "// 👤 PLAYER STATS")
        // 🎁 POWER-UP COLLECTION: search "// 🎁 POWER-UP COLLECTION"
        // ═══════════════════════════════════════════════════════════════════════════════

        class Player {
            constructor(x, y, maxHp, game) {
                this.x = x;
                this.y = y;
                this.lane = 1;
                this.maxHp = maxHp;
                this.hp = maxHp;
                this.shields = 0; // 🛡️ Power-up shield system (blocks hits)
                this.game = game;
                this.ship = SHIP_TYPES[game.currentShip];
                this.width = 40 * this.ship.size;
                this.height = 60 * this.ship.size;
                this.invincible = false;
                this.invincibleTimer = 0;

                // 🛡️ AAA: Ship shield capacity system (percentage-based absorption)
                this.maxShieldCapacity = this.ship.shieldCapacity || 0;
                this.currentShieldCapacity = this.maxShieldCapacity;
                this.shieldRechargeDelay = 0;
                this.shieldRechargeRate = 8; // ⚖️ BALANCE: Increased from 5% to 8% per second
                
                this.fireRate = (300 - (game.upgrades.attackSpeed * 30)) / this.ship.speed;
                this.fireTimer = 0;
                
                this.currentPowerUp = null;
                this.frame = 0;
                this.animTimer = 0;
                this.trail = [];
                
                this.abilityCooldown = 0;
                this.abilityCharges = null;
                this.phoenixRevived = false;
                this.titanArmorBoost = 0;
                this.phantomAlpha = 1;
                
                // ✨ SMOOTH MOVEMENT SYSTEM
                this.targetLane = this.lane;
                this.isMoving = false;
                this.movementProgress = 0;
                this.movementDuration = 200; // 200ms smooth transition
                
                if (this.ship.id === 'phoenix') {
                    this.abilityCharges = 1;
                }
            }
            
            update(deltaTime) {
                // ✨ SMOOTH LANE SLIDING
                if (this.isMoving) {
                    this.movementProgress += deltaTime;
                    
                    if (this.movementProgress >= this.movementDuration) {
                        // Movement complete
                        this.lane = this.targetLane;
                        this.isMoving = false;
                        this.movementProgress = 0;
                        this.x = this.game.getLaneX(this.lane);
                    } else {
                        // Smooth interpolation with easing
                        const t = this.movementProgress / this.movementDuration;
                        const eased = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t; // easeInOutQuad
                        
                        const startX = this.game.getLaneX(this.lane);
                        const endX = this.game.getLaneX(this.targetLane);
                        this.x = startX + (endX - startX) * eased;
                    }
                } else {
                    // Ensure we're at the correct lane position
                    const targetX = this.game.getLaneX(this.lane);
                    this.x = targetX;
                }
                
                this.trail.push({ x: this.x, y: this.y, alpha: 1 });
                if (this.trail.length > 5) this.trail.shift();
                this.trail.forEach(t => t.alpha *= 0.8);
                
                this.fireTimer += deltaTime;
                if (this.fireTimer >= this.fireRate) {
                    this.fireTimer = 0;
                    this.shoot();
                }
                
                if (this.invincible) {
                    this.invincibleTimer -= deltaTime;
                    if (this.invincibleTimer <= 0) {
                        this.invincible = false;
                    }
                }
                
                if (this.abilityCooldown > 0) {
                    this.abilityCooldown -= deltaTime;
                    if (this.abilityCooldown < 0) this.abilityCooldown = 0;
                }
                
                if (this.ship.id === 'phantom') {
                    this.phantomAlpha = this.invincible ? 0.3 : 1.0;
                }
                
                if (this.titanArmorBoost > 0) {
                    this.titanArmorBoost *= 0.99;
                }

                // 🛡️ AAA: Shield recharge system
                if (this.currentShieldCapacity < this.maxShieldCapacity) {
                    if (this.shieldRechargeDelay > 0) {
                        this.shieldRechargeDelay -= deltaTime;
                    } else {
                        // Recharge 5% per second
                        this.currentShieldCapacity += (this.shieldRechargeRate * deltaTime) / 1000;
                        if (this.currentShieldCapacity > this.maxShieldCapacity) {
                            this.currentShieldCapacity = this.maxShieldCapacity;
                        }
                    }
                }

                if (this.currentPowerUp) {
                    this.currentPowerUp.remaining--;
                    if (this.currentPowerUp.remaining <= 0) {
                        this.currentPowerUp = null;
                    }
                }
                
                this.animTimer += deltaTime;
                if (this.animTimer > 100) {
                    this.animTimer = 0;
                    this.frame = (this.frame + 1) % 4;
                }
            }
            
            render(ctx) {
                this.trail.forEach(t => {
                    ctx.save();
                    ctx.globalAlpha = t.alpha * 0.3 * this.phantomAlpha;
                    this.ship.render(ctx, t.x, t.y, this.width, this.height, this.game.currentTheme);
                    ctx.restore();
                });
                
                if (this.invincible && this.ship.id !== 'phantom' && Math.floor(this.invincibleTimer / 100) % 2 === 0) {
                    return;
                }
                
                ctx.save();
                ctx.globalAlpha = this.phantomAlpha;
                this.ship.render(ctx, this.x, this.y, this.width, this.height, this.game.currentTheme, this.phantomAlpha);
                ctx.restore();
                
                ctx.fillStyle = this.game.currentTheme.secondary;
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.game.currentTheme.secondary;
                for (let i = 0; i < 3; i++) {
                    ctx.globalAlpha = 0.6 - (i * 0.2);
                    ctx.fillRect(this.x - 2, this.y + this.height/2 + (i * 5), 4, 5);
                }
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
                
                if (this.ship.id === 'titan' && this.titanArmorBoost > 0) {
                    const boostAlpha = Math.min(this.titanArmorBoost / 50, 0.8);
                    ctx.save();
                    ctx.globalAlpha = boostAlpha;
                    ctx.strokeStyle = '#4169e1';
                    ctx.lineWidth = 4;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#4169e1';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, Math.max(this.width, this.height) / 2 + 15, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
                
                if (this.invincible && this.ship.id !== 'phantom') {
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#00ffff';
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i;
                        const radius = Math.max(this.width, this.height) / 2 + 10;
                        const x = this.x + Math.cos(angle) * radius;
                        const y = this.y + Math.sin(angle) * radius;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            }
            
            shoot() {
                let type = 'normal';
                if (this.currentPowerUp) {
                    type = this.currentPowerUp.type;
                }
                
                const proj = new Projectile(this.x, this.y - this.height / 2, this.lane, type, this.game);
                this.game.projectiles.push(proj);
                this.game.audio.playShoot();
            }
            
            moveLeft() {
                if (this.lane > 0 && !this.isMoving) {
                    // ✨ SMOOTH MOVEMENT: Set target and start animation
                    this.targetLane = this.lane - 1;
                    this.isMoving = true;
                    this.movementProgress = 0;
                    this.trail = [];
                    
                    if (this.ship.id === 'phantom') {
                        this.invincible = true;
                        this.invincibleTimer = 500;
                        this.game.createParticles(this.x, this.y, 10, '#8a2be2');
                    }
                }
            }
            
            moveRight() {
                if (this.lane < 2 && !this.isMoving) {
                    // ✨ SMOOTH MOVEMENT: Set target and start animation
                    this.targetLane = this.lane + 1;
                    this.isMoving = true;
                    this.movementProgress = 0;
                    this.trail = [];
                    
                    if (this.ship.id === 'phantom') {
                        this.invincible = true;
                        this.invincibleTimer = 500;
                        this.game.createParticles(this.x, this.y, 10, '#8a2be2');
                    }
                }
            }
            
            useAbility() {
                if (!this.ship.ability) return;
                if (this.abilityCooldown > 0) return;
                
                if (this.ship.id === 'phantom') {
                    this.invincible = true;
                    this.invincibleTimer = 2000;
                    this.abilityCooldown = 10000;
                    this.game.createFloatingText(this.x, this.y - 50, '✨ PHASE SHIFT!', '#8a2be2');
                    this.game.audio.playAbility();
                    for (let i = 0; i < 20; i++) {
                        this.game.createParticles(this.x, this.y, 1, '#8a2be2');
                    }
                }
                else if (this.ship.id === 'titan') {
                    this.titanArmorBoost = 50;
                    this.abilityCooldown = 15000;
                    this.game.createFloatingText(this.x, this.y - 50, '🛡️ FORTRESS!', '#4169e1');
                    this.game.audio.playAbility();
                    this.game.addScreenShake(5);
                }
            }
            
            activatePowerUp(type) {
                const configs = {
                    electric: { name: '⚡ ELECTRIC', color: '#00ffff', shots: 50, icon: '⚡' },
                    fire: { name: '🔥 FIRE', color: '#ff6600', shots: 50, icon: '🔥' },
                    fireworks: { name: '🎆 FIREWORKS', color: '#ff00ff', shots: 40, icon: '🎆' }
                };
                
                this.currentPowerUp = {
                    type: type,
                    remaining: configs[type].shots,
                    ...configs[type]
                };
            }
            
            takeDamage(amount) {
                if (this.invincible) return;

                let reduction = 1 - (this.game.upgrades.armor * 0.1);

                if (this.ship.id === 'titan' && this.titanArmorBoost > 0) {
                    reduction *= (1 - (this.titanArmorBoost / 100));
                }

                let actualDamage = amount * Math.max(reduction, 0.1);

                // 🛡️ Power-up shield blocks damage completely
                if (this.shields > 0) {
                    this.shields--;
                    this.game.createFloatingText(this.x, this.y, '🛡️ BLOCKED', '#00ccff');
                    this.game.createParticles(this.x, this.y, 10, '#00ccff');
                    this.game.audio.playHit();
                    this.game.addScreenShake(3);

                    // Don't reset combo or set invincibility when shield absorbs damage
                    return;
                }

                // 🛡️ AAA: Ship shield capacity absorbs percentage of damage
                if (this.currentShieldCapacity > 0) {
                    const shieldAbsorption = (this.currentShieldCapacity / 100);
                    const damageAbsorbed = actualDamage * shieldAbsorption;
                    const damageTaken = actualDamage - damageAbsorbed;

                    actualDamage = damageTaken;
                    this.currentShieldCapacity -= shieldAbsorption * 20; // Depletes shield
                    if (this.currentShieldCapacity < 0) this.currentShieldCapacity = 0;
                    this.shieldRechargeDelay = 2000; // ⚖️ BALANCE: Reduced from 3s to 2s for better flow

                    this.game.createFloatingText(this.x, this.y - 30, `⚡${Math.floor(damageAbsorbed)} ABSORBED`, '#00ddff');
                }

                this.hp -= actualDamage;
                
                if (this.hp <= 0 && this.ship.id === 'phoenix' && this.abilityCharges > 0) {
                    this.hp = this.maxHp * 0.5;
                    this.abilityCharges--;
                    this.phoenixRevived = true;
                    this.invincible = true;
                    this.invincibleTimer = 3000;
                    this.game.createFloatingText(this.x, this.y, '♻️ REBIRTH!', '#ff4500');
                    this.game.audio.playAbility();
                    this.game.flashIntensity = 1;
                    this.game.addScreenShake(15);
                    for (let i = 0; i < 50; i++) {
                        this.game.createParticles(this.x, this.y, 1, '#ff4500');
                    }
                    return;
                }
                
                if (this.ship.id === 'titan' && this.hp > 0) {
                    this.titanArmorBoost = Math.min(50, this.titanArmorBoost + 10);
                }
                
                this.invincible = true;
                this.invincibleTimer = 1000;
                
                this.game.damageTaken += actualDamage;
                this.game.combo = 0;
                this.game.superMissileReady = false;
                
                this.game.createParticles(this.x, this.y, 10, '#ff0033');
                this.game.createFloatingText(this.x, this.y, '-' + Math.floor(actualDamage), '#ff0033');
                this.game.audio.playDamage();
                this.game.addScreenShake(8);
            }
        }
        

        // ═══════════════════════════════════════════════════════════════════════════════
        // 👾 MODULE: ENEMY ENTITIES
        // ═══════════════════════════════════════════════════════════════════════════════
        // PURPOSE: Enemy types, AI behavior, stats, rendering
        // ⚖️ BALANCE CONFIG: HP, damage, credit drops (search: "// ⚖️ BALANCE CONFIG")
        // SAFE TO MODIFY: All numeric values (HP, damage, speed, credits)
        // ═══════════════════════════════════════════════════════════════════════════════

        class Enemy {
            constructor(lane, y, type, level, game) {
                this.lane = lane;
                this.y = y;
                this.type = type;
                this.game = game;
                this.isBoss = false;
                this.stunned = false; // 🎯 NEW: For Plasma Wave stun effect
                this.stunTimer = 0;   // 🎯 NEW: Duration of stun
                this.passedPenaltyApplied = false; // ☠▯ NEW: Track if pass penalty was applied
                
                switch (type) {
                    case 'drone':
                    // ⚖️ BALANCE CONFIG: Drone enemy stats
                    // SAFE TO MODIFY: All values below
                        this.hp = 30 + (level * 5);
                        this.maxHp = this.hp;
                        this.speed = 2 + (level * 0.1);
                        this.contactDamage = 15;
                        this.creditValue = 5 + level;
                        this.width = 40;
                        this.height = 40;
                        this.size = 40;
                        break;
                    case 'turret':
                    // ⚖️ BALANCE CONFIG: Turret enemy stats
                        this.hp = 50 + (level * 8);
                        this.maxHp = this.hp;
                        this.speed = 1;
                        this.contactDamage = 25;
                        this.creditValue = 10 + (level * 2);
                        this.width = 50;
                        this.height = 50;
                        this.size = 50;
                        this.shootTimer = Math.random() * 3000;
                        break;
                    case 'barricade':
                    // ⚖️ BALANCE CONFIG: Barricade enemy stats
                        this.hp = 100 + (level * 15);
                        this.maxHp = this.hp;
                        this.speed = 0;
                        this.contactDamage = 30;
                        this.creditValue = 20 + (level * 3);
                        this.width = 120;
                        this.height = 80;
                        this.size = 100;
                        break;
                }
                
                this.x = game.getLaneX(lane);
                this.rotation = 0;
            }
            
            update(deltaTime) {
                // 🎯 NEW: Handle stun mechanics
                if (this.stunned) {
                    this.stunTimer -= deltaTime;
                    if (this.stunTimer <= 0) {
                        this.stunned = false;
                        this.stunTimer = 0;
                    }
                    // Don't move or shoot while stunned
                    return;
                }
                
                this.y += this.speed;
                this.rotation += 0.05;
                if (this.type === 'turret') {
                    this.shootTimer += deltaTime;
                }
            }
            
            canShoot() {
                if (this.type === 'turret' && this.shootTimer >= 3000) {
                    this.shootTimer = 0;
                    return true;
                }
                return false;
            }
            
            render(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                const theme = this.game.currentTheme;
                
                if (this.type === 'drone') {
                    ctx.rotate(this.rotation);
                    ctx.fillStyle = '#ff0033';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ff0033';
                    ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(0, 0, 8, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'turret') {
                    if (this.shootTimer > 2500) {
                        ctx.strokeStyle = '#ff0000';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(0, 0, this.width / 2 + 10, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    ctx.fillStyle = '#1e3a5f';
                    ctx.strokeStyle = '#ff6600';
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ff6600';
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i;
                        const x = Math.cos(angle) * this.width / 2;
                        const y = Math.sin(angle) * this.width / 2;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else if (this.type === 'barricade') {
                    ctx.fillStyle = this.game.hexToRgba(theme.primary, 0.3);
                    ctx.strokeStyle = theme.primary;
                    ctx.lineWidth = 4;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = theme.primary;
                    ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    ctx.strokeRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    ctx.fillStyle = '#fff';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = theme.primary;
                    ctx.font = 'bold 36px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText(Math.ceil(this.hp), 0, 10);
                }

                // 🚀 AAA: Elite enemy golden glow effect
                if (this.isElite) {
                    this.eliteGlow = (this.eliteGlow || 0) + 0.1;
                    const glowIntensity = Math.sin(this.eliteGlow) * 0.5 + 0.5;

                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 4;
                    ctx.shadowBlur = 30 * glowIntensity;
                    ctx.shadowColor = '#ffd700';
                    ctx.globalAlpha = 0.8 * glowIntensity;

                    // Draw elite aura
                    ctx.beginPath();
                    ctx.arc(0, 0, Math.max(this.width, this.height) / 2 + 15, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.globalAlpha = 1;

                    // Elite star indicator
                    ctx.font = 'bold 20px Courier New';
                    ctx.fillStyle = '#ffd700';
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 10;
                    ctx.fillText('⭐', 0, -this.height / 2 - 20);
                }

                ctx.restore();

                // 🎯 NEW: Visual effect for stunned enemies
                if (this.stunned) {
                    ctx.save();
                    ctx.strokeStyle = '#ff00ff';
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#ff00ff';
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, Math.max(this.width, this.height) / 2 + 15, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.shadowBlur = 0;
                    
                    // Add "STUNNED" text above enemy
                    ctx.fillStyle = '#ff00ff';
                    ctx.font = 'bold 12px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText('STUNNED', this.x, this.y - this.height / 2 - 20);
                    ctx.restore();
                }
                
                if (this.type !== 'barricade' && this.hp < this.maxHp) {
                    const barWidth = this.width;
                    const barHeight = 5;
                    const barX = this.x - barWidth / 2;
                    const barY = this.y - this.height / 2 - 10;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    const hpPercent = this.hp / this.maxHp;
                    ctx.fillStyle = hpPercent > 0.5 ? '#00ff88' : hpPercent > 0.25 ? '#ffd700' : '#ff0033';
                    ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);
                }
            }
            
            takeDamage(amount) {
                this.hp -= amount;
                this.game.createParticles(this.x, this.y, 3, this.game.currentTheme.primary);
            }
            
            destroy() {}
        }
        

        // ═══════════════════════════════════════════════════════════════════════════════
        // 👹 MODULE: BOSS ENTITY
        // ═══════════════════════════════════════════════════════════════════════════════
        // PURPOSE: Boss battles, special mechanics, multi-phase fights
        // SAFE TO MODIFY: Boss HP, damage, phases
        // ═══════════════════════════════════════════════════════════════════════════════

        class Boss extends Enemy {
            constructor(lane, y, level, game) {
                super(lane, y, 'drone', level, game);
                this.isBoss = true;
                const sizeMultiplier = 1 + Math.floor(level / 5);

                // ⚖️ BALANCE v0.1.2: Progressive HP scaling for early levels
                if (level <= 5) {
                    // Levels 1-5: 40% reduction for learning curve
                    // Level 1: 840 HP, Level 5: 2100 HP
                    this.hp = 420 + (level * 420);
                } else {
                    // Levels 6+: Full challenge
                    this.hp = 700 + (level * 700);
                }
                this.maxHp = this.hp;

                // ⚖️ BALANCE v0.1.2: Progressive armor for early levels
                if (level <= 5) {
                    this.armor = 0.15; // 15% damage reduction for levels 1-5
                } else {
                    this.armor = 0.30; // 30% damage reduction for levels 6+
                }
                this.speed = 0;
                this.contactDamage = 50;
                // ⚖️ BALANCE: Restored boss credits to original value (risk/reward balance)
                this.creditValue = 200 + (level * 50);
                this.width = 120 * sizeMultiplier;
                this.height = 120 * sizeMultiplier;
                this.size = 150 * sizeMultiplier;
                this.phase = 1;
                this.shootTimer = 0;
                
                this.targetY = 150;
                this.targetLane = lane;
                this.dodgeTimer = 0;
                this.dodgeCooldown = 2000;
                this.minionSpawnTimer = 0;
                this.minionSpawnRate = 5000;
                this.attackPattern = 'SINGLE';
                this.isLocked = false;
                this.telegraphTimer = 0;
                this.nextAttackLanes = [];
            }
            
            update(deltaTime) {
                this.rotation += 0.05;
                
                if (!this.isLocked) {
                    this.y += 1;
                    if (this.y >= this.targetY) {
                        this.y = this.targetY;
                        this.isLocked = true;
                        this.game.bossBattleActive = true;
                        this.game.bossBattlePhase = 'ACTIVE';
                    }
                    return;
                }
                
                const targetX = this.game.getLaneX(this.targetLane);
                const dx = targetX - this.x;
                if (Math.abs(dx) > 5) {
                    this.x += Math.sign(dx) * 2;
                } else {
                    this.x = targetX;
                }
                
                const hpPercent = this.hp / this.maxHp;
                if (hpPercent > 0.75) {
                    this.phase = 1;
                    this.attackPattern = 'SINGLE';
                    this.minionSpawnRate = 6000;
                } else if (hpPercent > 0.5) {
                    this.phase = 2;
                    this.attackPattern = 'SPREAD';
                    this.minionSpawnRate = 5000;
                } else if (hpPercent > 0.25) {
                    this.phase = 3;
                    this.attackPattern = 'RAPID';
                    this.minionSpawnRate = 4000;
                } else {
                    this.phase = 4;
                    this.attackPattern = 'BERSERK';
                    this.minionSpawnRate = 3000;
                }
                
                this.dodgeTimer -= deltaTime;
                if (this.dodgeTimer <= 0 && Math.random() < 0.4) {
                    const playerLane = this.game.player.lane;
                    const avoidPlayer = Math.random() < 0.6;
                    if (avoidPlayer && playerLane === this.targetLane) {
                        const options = [0, 1, 2].filter(l => l !== playerLane);
                        this.targetLane = options[Math.floor(Math.random() * options.length)];
                    } else if (!avoidPlayer) {
                        this.targetLane = Math.floor(Math.random() * 3);
                    }
                    this.dodgeTimer = this.dodgeCooldown;
                }
                
                this.shootTimer += deltaTime;
                this.telegraphTimer -= deltaTime;
                
                let shootRate = 2000 / this.phase;
                if (this.shootTimer > shootRate) {
                    this.shootTimer = 0;
                    this.executeAttackPattern();
                }
                
                this.minionSpawnTimer += deltaTime;
                if (this.minionSpawnTimer > this.minionSpawnRate) {
                    this.minionSpawnTimer = 0;
                    this.spawnMinionWave();
                }
            }
            
            executeAttackPattern() {
                this.telegraphTimer = 1500; // ✨ INCREASED: 500ms → 1500ms warning time
                
                switch(this.attackPattern) {
                    case 'SINGLE':
                        // ✨ PHASE 1: Single lane pursuit (Easy)
                        this.nextAttackLanes = [this.game.player.lane];
                        setTimeout(() => {
                            this.game.enemyProjectiles.push(
                                new EnemyProjectile(this.game.getLaneX(this.game.player.lane), this.y + 60, this.game.player.lane, this.game)
                            );
                        }, 1500);
                        break;
                        
                    case 'SPREAD':
                        // ✨ PHASE 2: Side sweep - 2 lanes, always 1 safe (Medium)
                        const sweepLeft = Math.random() < 0.5;
                        this.nextAttackLanes = sweepLeft ? [0, 1] : [1, 2];
                        setTimeout(() => {
                            this.nextAttackLanes.forEach(lane => {
                                this.game.enemyProjectiles.push(
                                    new EnemyProjectile(this.game.getLaneX(lane), this.y + 60, lane, this.game)
                                );
                            });
                        }, 1500);
                        break;
                        
                    case 'RAPID':
                        // ✨ PHASE 3: Random dual - 2 random lanes, 1 always safe (Hard)
                        const allLanes = [0, 1, 2];
                        const safeLane = Math.floor(Math.random() * 3);
                        allLanes.splice(safeLane, 1);
                        this.nextAttackLanes = allLanes;
                        setTimeout(() => {
                            this.nextAttackLanes.forEach(lane => {
                                this.game.enemyProjectiles.push(
                                    new EnemyProjectile(this.game.getLaneX(lane), this.y + 60, lane, this.game)
                                );
                            });
                        }, 1500);
                        break;
                        
                    case 'BERSERK':
                        // ✨ PHASE 4: Rapid pursuit - fast single shots, dodgeable (Very Hard)
                        this.nextAttackLanes = [this.game.player.lane];
                        for (let i = 0; i < 4; i++) {
                            setTimeout(() => {
                                const lane = this.game.player.lane;
                                this.game.enemyProjectiles.push(
                                    new EnemyProjectile(this.game.getLaneX(lane), this.y + 60, lane, this.game)
                                );
                            }, 1500 + (i * 250));
                        }
                        break;
                }
            }
            
            spawnMinionWave() {
                const minionCount = 3 + this.phase;
                this.game.createFloatingText(this.x, this.y - 80, '⚡ MINION WAVE! ⚡', '#ff00ff');
                
                for (let i = 0; i < minionCount; i++) {
                    setTimeout(() => {
                        const lane = Math.floor(Math.random() * 3);
                        const minion = new Enemy(lane, this.y + 100, 'drone', this.game.currentLevel, this.game);
                        minion.speed = 1.5 + (this.phase * 0.5);
                        this.game.enemies.push(minion);
                        this.game.createParticles(this.game.getLaneX(lane), this.y + 100, 10, '#ff00ff');
                    }, i * 200);
                }
            }
            
            render(ctx) {
                if (this.telegraphTimer > 0 && this.nextAttackLanes.length > 0) {
                    this.nextAttackLanes.forEach(lane => {
                        const x = this.game.getLaneX(lane);
                        ctx.strokeStyle = '#ff0000';
                        ctx.lineWidth = 4;
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = '#ff0000';
                        ctx.globalAlpha = 0.6;
                        ctx.beginPath();
                        ctx.moveTo(x, this.y + 80);
                        ctx.lineTo(x, this.game.height);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                        ctx.shadowBlur = 0;
                    });
                }
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.font = '48px Courier New';
                ctx.fillText('👑', -24, -80);
                ctx.rotate(this.rotation);
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.width / 2);
                gradient.addColorStop(0, '#ff6600');
                gradient.addColorStop(0.5, '#ff0033');
                gradient.addColorStop(1, '#8b0000');
                ctx.fillStyle = gradient;
                ctx.shadowBlur = 30;
                ctx.shadowColor = '#ff0000';
                ctx.beginPath();
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI / 4) * i;
                    const radius = this.width / 2 + (i % 2 === 0 ? 10 : -10);
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(0, 0, 20, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            
            takeDamage(amount) {
                // ✨ FIXED: Apply boss armor reduction
                const reducedDamage = amount * (1 - this.armor);
                this.hp -= reducedDamage;
                
                // Create particles for visual feedback
                this.game.createParticles(this.x, this.y, 5, '#ff6600');
                
                // Show reduced damage with different color
                this.game.createFloatingText(
                    this.x + 30,
                    this.y - 40,
                    '-' + Math.floor(reducedDamage) + ' 🛡️',
                    '#ffaa00'  // Orange to show armor working
                );
                
                // Boss armor shield effect
                if (this.armor > 0) {
                    this.game.createParticles(this.x, this.y, 3, '#4169e1');
                }
            }
        }
        

        // ═══════════════════════════════════════════════════════════════════════════════
        // 💥 MODULE: PROJECTILE SYSTEMS
        // ═══════════════════════════════════════════════════════════════════════════════
        // PURPOSE: Player shots, super missiles, enemy projectiles
        // SAFE TO MODIFY: Projectile damage, speed
        // ═══════════════════════════════════════════════════════════════════════════════

        class Projectile {
            constructor(x, y, lane, type, game) {
                this.x = x;
                this.y = y;
                this.lane = lane;
                this.type = type;
                this.game = game;
                this.speed = 8;
                this.width = 4;
                this.height = 15;
                this.isSuperMissile = false;
                this.remove = false;
                this.colors = {
                    normal: game.currentTheme.primary,
                    electric: '#00ffff',
                    fire: '#ff6600',
                    fireworks: '#ff00ff'
                };
            }
            
            update(deltaTime) {
                this.y -= this.speed;
            }
            
            render(ctx) {
                const color = this.colors[this.type] || this.colors.normal;
                ctx.fillStyle = color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = color;
                if (this.type === 'fire') {
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y - this.height);
                    ctx.lineTo(this.x - this.width, this.y);
                    ctx.lineTo(this.x + this.width, this.y);
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 'electric') {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y - this.height);
                    ctx.lineTo(this.x - 3, this.y - this.height / 2);
                    ctx.lineTo(this.x + 3, this.y - this.height / 2);
                    ctx.lineTo(this.x, this.y);
                    ctx.stroke();
                } else if (this.type === 'fireworks') {
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (Math.PI * 2 * i) / 5 - Math.PI / 2;
                        const x = this.x + Math.cos(angle) * 8;
                        const y = this.y + Math.sin(angle) * 8;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.fillRect(this.x - this.width / 2, this.y, this.width, this.height);
                }
                ctx.shadowBlur = 0;
            }
        }
        
        // 🌈 NEW: Damage Field for Ultimate Annihilation (Combo 20+)
        class DamageField {
            constructor(x, y, game) {
                this.x = x;
                this.y = y;
                this.game = game;
                this.radius = 0;
                this.maxRadius = 400;
                this.life = 2000; // 2 seconds
                this.maxLife = this.life;
                this.damageInterval = 200; // Deal damage every 200ms
                this.damageTimer = 0;
                this.colors = ['#ff0000', '#ff6600', '#ffff00', '#00ff00', '#00ffff', '#0000ff', '#ff00ff']; // Rainbow
                this.colorIndex = 0;
                this.rotation = 0;
            }
            
            update(deltaTime) {
                this.life -= deltaTime;
                this.damageTimer += deltaTime;
                this.rotation += 0.05;
                
                // Expand radius
                if (this.radius < this.maxRadius) {
                    this.radius += 10;
                }
                
                // Cycle through rainbow colors
                if (Math.random() < 0.1) {
                    this.colorIndex = (this.colorIndex + 1) % this.colors.length;
                }
                
                // Deal damage to enemies in field
                if (this.damageTimer >= this.damageInterval) {
                    this.damageTimer = 0;
                    this.damageEnemiesInField();
                }
            }
            
            damageEnemiesInField() {
                for (let enemy of this.game.enemies) {
                    const dx = enemy.x - this.x;
                    const dy = enemy.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= this.radius) {
                        let fieldDamage = 50; // 50 damage per tick
                        
                        // 🔥 FIXED: Bosses take only 30% damage from damage field
                        if (enemy.isBoss) {
                            fieldDamage *= 0.3;
                        }
                        
                        enemy.takeDamage(fieldDamage);
                        this.game.createFloatingText(enemy.x, enemy.y, '-' + Math.floor(fieldDamage), '#ffffff');
                        this.game.createParticles(enemy.x, enemy.y, 3, this.colors[this.colorIndex]);
                        
                        // 🔥 FIXED: Don't auto-destroy bosses, let normal game loop handle it
                        if (enemy.hp <= 0 && !enemy.isBoss) {
                            const index = this.game.enemies.indexOf(enemy);
                            if (index > -1) {
                                this.game.handleEnemyDestroyed(enemy, index);
                            }
                        }
                    }
                }
            }
            
            render(ctx) {
                const alpha = this.life / this.maxLife;
                
                // Rainbow pulsing circle
                ctx.save();
                ctx.globalAlpha = alpha * 0.3;
                
                for (let i = 0; i < this.colors.length; i++) {
                    const offset = (this.rotation + i * Math.PI * 2 / this.colors.length) % (Math.PI * 2);
                    const r = this.radius * (0.7 + Math.sin(offset) * 0.3);
                    
                    ctx.strokeStyle = this.colors[(this.colorIndex + i) % this.colors.length];
                    ctx.lineWidth = 15;
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = this.colors[(this.colorIndex + i) % this.colors.length];
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, r, offset, offset + Math.PI * 2 / this.colors.length);
                    ctx.stroke();
                }
                
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
                ctx.restore();
            }
        }
        
        class SuperMissile extends Projectile {
            constructor(x, y, game) {
                super(x, y, 1, 'super', game);
                this.isSuperMissile = true;
                this.width = 20;
                this.height = 40;
                this.speed = 12;
                this.trail = [];
                this.exploded = false;
            }
            
            update(deltaTime) {
                super.update(deltaTime);
                this.trail.push({ x: this.x, y: this.y, alpha: 1, size: this.width });
                if (this.trail.length > 20) this.trail.shift();
                this.trail.forEach(t => {
                    t.alpha *= 0.95;
                    t.size *= 0.98;
                });
                if (this.y < 100 && !this.exploded) {
                    this.explode();
                }
            }
            
            explode() {
                this.exploded = true;
                this.remove = true;
                this.game.addScreenShake(20);
                this.game.flashIntensity = 1;
                this.game.hitStop = 50;
                for (let i = 0; i < 100; i++) {
                    this.game.createParticles(this.x, this.y, 1, '#ffff00');
                }
                
                // ✨ FIXED: Deal 250 damage instead of instant-kill
                for (let j = this.game.enemies.length - 1; j >= 0; j--) {
                    const enemy = this.game.enemies[j];
                    const superMissileDamage = 250;
                    
                    // Apply damage to enemy
                    enemy.takeDamage(superMissileDamage);
                    
                    // Show dramatic damage number
                    this.game.createFloatingText(
                        enemy.x,
                        enemy.y - 30,
                        '🔥 -' + superMissileDamage,
                        '#ffff00'
                    );
                    
                    // Only destroy enemy if HP reaches 0
                    if (enemy.hp <= 0) {
                        this.game.handleEnemyDestroyed(enemy, j);
                    }
                }
            }
            
            render(ctx) {
                this.trail.forEach(t => {
                    ctx.save();
                    ctx.globalAlpha = t.alpha;
                    ctx.fillStyle = '#ff6600';
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#ffff00';
                    ctx.fillRect(t.x - t.size/2, t.y, t.size, t.size * 2);
                    ctx.restore();
                });
                ctx.fillStyle = '#ffff00';
                ctx.shadowBlur = 40;
                ctx.shadowColor = '#ffff00';
                ctx.fillRect(this.x - this.width/2, this.y - this.height, this.width, this.height);
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(this.x, this.y - this.height/2, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }
        
        class EnemyProjectile {
            constructor(x, y, lane, game) {
                this.x = x;
                this.y = y;
                this.lane = lane;
                this.game = game;
                this.speed = 5;
                this.width = 6;
                this.height = 12;
            }
            
            update(deltaTime) {
                this.y += this.speed;
            }
            
            render(ctx) {
                ctx.fillStyle = '#ff0033';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ff0033';
                ctx.fillRect(this.x - this.width / 2, this.y, this.width, this.height);
                ctx.shadowBlur = 0;
            }
        }
        

        // ═══════════════════════════════════════════════════════════════════════════════
        // ⚡ MODULE: POWER-UP SYSTEM
        // ═══════════════════════════════════════════════════════════════════════════════
        // PURPOSE: Power-up types, effects, collection
        // ⚡ POWER-UP EFFECTS: Duration, shot counts (search: "// ⚡ POWER-UP EFFECTS")
        // SAFE TO MODIFY: Power-up durations, effects
        // ═══════════════════════════════════════════════════════════════════════════════

        class PowerUp {
            constructor(lane, y, type, game) {
                this.lane = lane;
                this.y = y;
                this.type = type;
                this.game = game;
                this.x = game.getLaneX(lane);
                this.size = 30;
                this.rotation = 0;
                this.icons = { electric: '⚡', fire: '🔥', fireworks: '🎆', shield: '🛡️' }; // 🛡️ NEW
                this.colors = { electric: '#00ffff', fire: '#ff6600', fireworks: '#ff00ff', shield: '#00ccff', freeze: '#87ceeb', pierce: '#ffff00', homing: '#ff1493', timeSlow: '#9370db', rage: '#ff0000', multishot: '#ffd700' }; // 🚀 AAA: Extended with 6 new types
            }
            
            update(deltaTime) {
                this.y += 2;
                this.rotation += 0.1;
            }
            
            render(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.colors[this.type];
                ctx.fillStyle = this.game.hexToRgba(this.colors[this.type], 0.3);
                ctx.beginPath();
                ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.font = '32px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(this.icons[this.type], 0, 10);
                ctx.restore();
            }
        }
        

        // ═══════════════════════════════════════════════════════════════════════════════
        // ✨ MODULE: VISUAL EFFECTS
        // ═══════════════════════════════════════════════════════════════════════════════
        // PURPOSE: Particles, explosions, floating text, screen effects
        // SAFE TO MODIFY: Particle counts, colors, durations
        // ═══════════════════════════════════════════════════════════════════════════════

        class Particle {
            constructor(x, y, color, explosion = false) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.vx = (Math.random() - 0.5) * (explosion ? 8 : 4);
                this.vy = (Math.random() - 0.5) * (explosion ? 8 : 4);
                this.life = explosion ? 60 : 30;
                this.maxLife = this.life;
                this.size = explosion ? Math.random() * 8 + 4 : Math.random() * 4 + 2;
            }
            
            update(deltaTime) {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.2;
                this.life--;
            }
            
            render(ctx) {
                const alpha = this.life / this.maxLife;
                ctx.fillStyle = this.color;
                ctx.globalAlpha = alpha;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1;
            }
        }
        
        class FloatingText {
            constructor(x, y, text, color) {
                this.x = x;
                this.y = y;
                this.text = text;
                this.color = color;
                this.vy = -2;
                this.life = 60;
                this.maxLife = this.life;
            }
            
            update(deltaTime) {
                this.y += this.vy;
                this.life--;
            }
            
            render(ctx) {
                const alpha = this.life / this.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.font = 'bold 20px Courier New';
                ctx.textAlign = 'center';
                ctx.shadowBlur = 5;
                ctx.shadowColor = this.color;
                ctx.fillText(this.text, this.x, this.y);
                ctx.restore();
            }
        }


        // ═══════════════════════════════════════════════════════════════════════════════
        // 🔫 MODULE: BOSS WEAPON SYSTEM
        // ═══════════════════════════════════════════════════════════════════════════════
        // PURPOSE: Special weapons unlocked via combos, used in boss battles
        // FEATURES: 5 weapons + radial wheel UI + charge system
        // ═══════════════════════════════════════════════════════════════════════════════

        // ❄️ FREEZING TORNADO - Freeze all enemies and deal damage over time
        class FreezingTornado {
            constructor(targetX, targetY, game) {
                this.game = game;
                this.x = targetX;
                this.y = targetY;
                this.phase = 'SPAWNING'; // SPAWNING → ACTIVE → FADING → DONE
                this.timer = 0;
                this.remove = false;
                this.rotation = 0;
                this.radius = 0;
                this.maxRadius = 150;
                this.height = 0;
                this.maxHeight = 400;
                this.particles = [];
                this.freezeDuration = 4000; // 4 seconds
                this.damageInterval = 500; // Damage every 0.5 seconds
                this.damageTimer = 0;
                this.frozenEnemies = new Set();
                this.originalEnemySpeeds = new Map();
                this.totalDuration = 6000; // Total effect duration
            }

            update(deltaTime) {
                this.timer += deltaTime;
                this.rotation += deltaTime * 0.005; // Spinning effect
                this.damageTimer += deltaTime;

                switch(this.phase) {
                    case 'SPAWNING':
                        // Grow tornado
                        this.radius = Math.min(this.maxRadius, this.radius + (deltaTime * 0.3));
                        this.height = Math.min(this.maxHeight, this.height + (deltaTime * 0.5));

                        // Create ice particles
                        if (Math.random() < 0.3) {
                            this.createIceParticle();
                        }

                        if (this.timer >= 1000) {
                            this.phase = 'ACTIVE';
                            this.timer = 0;
                            this.freezeEnemies();
                            // Note: Enemies are frozen individually (speed = 0), no global timeScale needed
                        }
                        break;

                    case 'ACTIVE':
                        // Maintain tornado, deal periodic damage
                        if (this.damageTimer >= this.damageInterval) {
                            this.dealDamage();
                            this.damageTimer = 0;
                        }

                        // Create ice particles
                        if (Math.random() < 0.5) {
                            this.createIceParticle();
                        }

                        if (this.timer >= this.freezeDuration) {
                            this.phase = 'FADING';
                            this.timer = 0;
                            this.unfreezeEnemies();
                            // Enemies restored to original speed
                        }
                        break;

                    case 'FADING':
                        // Shrink tornado
                        this.radius *= 0.95;
                        this.height *= 0.95;

                        if (this.timer >= 1000 || this.radius < 10) {
                            this.phase = 'DONE';
                            this.remove = true;
                        }
                        break;
                }

                // Update ice particles
                this.particles.forEach(p => {
                    p.x += Math.cos(p.angle) * p.speed * (deltaTime / 16);
                    p.y += Math.sin(p.angle) * p.speed * (deltaTime / 16);
                    p.y -= p.rise * (deltaTime / 16);
                    p.life -= deltaTime / 1000;
                    p.angle += p.spin;
                });
                this.particles = this.particles.filter(p => p.life > 0);
            }

            createIceParticle() {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * this.radius;
                this.particles.push({
                    x: this.x + Math.cos(angle) * distance,
                    y: this.y + Math.sin(angle) * distance,
                    angle: angle,
                    speed: 1 + Math.random() * 2,
                    rise: 2 + Math.random() * 3,
                    spin: (Math.random() - 0.5) * 0.1,
                    life: 2 + Math.random() * 2,
                    size: 3 + Math.random() * 5,
                    opacity: 0.5 + Math.random() * 0.5
                });
            }

            freezeEnemies() {
                // Freeze all enemies on screen
                this.game.enemies.forEach(enemy => {
                    if (!enemy.isBoss) {
                        this.frozenEnemies.add(enemy);
                        // Store original speed and set to 0
                        if (!this.originalEnemySpeeds.has(enemy)) {
                            this.originalEnemySpeeds.set(enemy, enemy.speed);
                            enemy.speed = 0;
                            // Add frozen visual flag
                            enemy.frozen = true;
                        }
                    }
                });

                // Show notification
                this.game.createFloatingText(
                    this.x,
                    this.y - 200,
                    '❄️ FROZEN! ❄️',
                    '#00ffff',
                    48
                );
            }

            unfreezeEnemies() {
                // Restore enemy speeds (only if enemy still exists in the game)
                this.frozenEnemies.forEach(enemy => {
                    // Check if enemy still exists before unfreezing to prevent memory leaks
                    if (this.game.enemies.includes(enemy) && this.originalEnemySpeeds.has(enemy)) {
                        enemy.speed = this.originalEnemySpeeds.get(enemy);
                        enemy.frozen = false;
                    }
                });
                this.frozenEnemies.clear();
                this.originalEnemySpeeds.clear();
            }

            dealDamage() {
                // Deal damage to frozen enemies
                const damage = 50;
                this.frozenEnemies.forEach(enemy => {
                    if (enemy.hp > 0) {
                        enemy.hp -= damage;
                        // Create small damage indicator
                        this.game.createFloatingText(
                            enemy.x,
                            enemy.y,
                            `-${damage}`,
                            '#00ffff',
                            20
                        );
                    }
                });
            }

            render(ctx) {
                ctx.save();

                // Blue screen tint
                if (this.phase === 'ACTIVE' || this.phase === 'SPAWNING') {
                    const tintOpacity = this.phase === 'SPAWNING'
                        ? (this.timer / 1000) * 0.15
                        : 0.15;
                    ctx.fillStyle = `rgba(0, 100, 255, ${tintOpacity})`;
                    ctx.fillRect(0, 0, this.game.width, this.game.height);
                }

                // Tornado spiral effect
                for (let i = 0; i < 10; i++) {
                    const layerHeight = (this.height / 10) * i;
                    const layerRadius = this.radius * (1 - i / 10);
                    const layerRotation = this.rotation + (i * 0.3);
                    const layerY = this.y - layerHeight;

                    // Draw spiral segments
                    for (let j = 0; j < 8; j++) {
                        const angle = layerRotation + (Math.PI * 2 / 8) * j;
                        const x1 = this.x + Math.cos(angle) * layerRadius;
                        const y1 = layerY;
                        const x2 = this.x + Math.cos(angle + 0.5) * layerRadius * 0.8;
                        const y2 = layerY;

                        ctx.strokeStyle = `rgba(100, 200, 255, ${0.3 + i / 20})`;
                        ctx.lineWidth = 8 - (i * 0.5);
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }

                // Tornado core
                const coreGradient = ctx.createLinearGradient(
                    this.x, this.y,
                    this.x, this.y - this.height
                );
                coreGradient.addColorStop(0, 'rgba(200, 230, 255, 0.3)');
                coreGradient.addColorStop(0.5, 'rgba(150, 200, 255, 0.5)');
                coreGradient.addColorStop(1, 'rgba(100, 150, 255, 0.2)');

                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x - this.radius * 0.3, this.y);
                ctx.lineTo(this.x - this.radius * 0.1, this.y - this.height);
                ctx.lineTo(this.x + this.radius * 0.1, this.y - this.height);
                ctx.lineTo(this.x + this.radius * 0.3, this.y);
                ctx.closePath();
                ctx.fill();

                // Ice particles
                this.particles.forEach(p => {
                    ctx.fillStyle = `rgba(200, 240, 255, ${p.opacity * p.life / 2})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();

                    // Snowflake sparkle
                    ctx.strokeStyle = `rgba(255, 255, 255, ${p.opacity * p.life / 2})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(p.x - p.size, p.y);
                    ctx.lineTo(p.x + p.size, p.y);
                    ctx.moveTo(p.x, p.y - p.size);
                    ctx.lineTo(p.x, p.y + p.size);
                    ctx.stroke();
                });

                // Glow effect at base
                if (this.phase !== 'FADING') {
                    const baseGradient = ctx.createRadialGradient(
                        this.x, this.y, 0,
                        this.x, this.y, this.radius
                    );
                    baseGradient.addColorStop(0, 'rgba(200, 230, 255, 0.5)');
                    baseGradient.addColorStop(0.6, 'rgba(100, 180, 255, 0.3)');
                    baseGradient.addColorStop(1, 'rgba(50, 150, 255, 0)');

                    ctx.fillStyle = baseGradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }

            // Cleanup when removed
            cleanup() {
                this.unfreezeEnemies();
                if (this.game.timeScale !== undefined) {
                    this.game.timeScale = 1.0;
                }
            }
        }

        // 💣 STINK MISSILE - Launch 3 homing missiles that track the boss
        class StinkMissile {
            constructor(game) {
                this.game = game;
                this.missiles = [];
                this.remove = false;

                // Launch 3 missiles from the 3 lanes
                const lanes = [this.game.canvas.width * 0.25, this.game.canvas.width * 0.5, this.game.canvas.width * 0.75];
                lanes.forEach((laneX, index) => {
                    setTimeout(() => {
                        this.missiles.push({
                            x: laneX,
                            y: this.game.canvas.height - 100,
                            vx: 0,
                            vy: 0,
                            speed: 8,
                            rotation: -Math.PI / 2,
                            trail: [],
                            active: true
                        });
                    }, index * 200); // Stagger launches by 200ms
                });
            }

            update(deltaTime) {
                let allInactive = true;

                this.missiles.forEach(missile => {
                    if (!missile.active) return;
                    allInactive = false;

                    // Homing behavior - track the boss
                    if (this.game.boss && !this.game.boss.remove) {
                        const dx = this.game.boss.x - missile.x;
                        const dy = this.game.boss.y - missile.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const targetAngle = Math.atan2(dy, dx);

                        // Smooth rotation towards target
                        let angleDiff = targetAngle - missile.rotation;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        missile.rotation += angleDiff * 0.1;

                        // Move in the direction of rotation
                        missile.vx = Math.cos(missile.rotation) * missile.speed;
                        missile.vy = Math.sin(missile.rotation) * missile.speed;
                        missile.x += missile.vx * (deltaTime / 16);
                        missile.y += missile.vy * (deltaTime / 16);

                        // Add trail
                        missile.trail.push({ x: missile.x, y: missile.y, life: 1.0 });
                        if (missile.trail.length > 20) missile.trail.shift();

                        // Update trail life
                        missile.trail.forEach(t => t.life -= 0.05);

                        // Check collision with boss
                        if (distance < 50) {
                            this.hitBoss(missile);
                            missile.active = false;
                        }

                        // Remove if off screen
                        if (missile.x < -50 || missile.x > this.game.canvas.width + 50 ||
                            missile.y < -50 || missile.y > this.game.canvas.height + 50) {
                            missile.active = false;
                        }
                    } else {
                        missile.active = false;
                    }
                });

                if (allInactive) {
                    this.remove = true;
                }
            }

            hitBoss(missile) {
                const damage = 500;
                if (this.game.boss && !this.game.boss.remove) {
                    this.game.boss.hp -= damage;

                    // Create explosion effect at impact
                    this.game.createFloatingText(
                        missile.x,
                        missile.y,
                        `-${damage}`,
                        '#00ff00',
                        32
                    );

                    // Small explosion particles
                    for (let i = 0; i < 20; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = 2 + Math.random() * 4;
                        this.game.particles.push({
                            x: missile.x,
                            y: missile.y,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            size: 4 + Math.random() * 6,
                            life: 1.0,
                            color: '#00ff00',
                            decay: 0.02
                        });
                    }
                }
            }

            draw(ctx) {
                this.missiles.forEach(missile => {
                    if (!missile.active) return;

                    // Draw trail
                    missile.trail.forEach((t, index) => {
                        if (t.life > 0) {
                            ctx.globalAlpha = t.life * 0.6;
                            ctx.fillStyle = '#00ff00';
                            const size = 4 * t.life;
                            ctx.fillRect(t.x - size/2, t.y - size/2, size, size);
                        }
                    });
                    ctx.globalAlpha = 1.0;

                    // Draw missile body
                    ctx.save();
                    ctx.translate(missile.x, missile.y);
                    ctx.rotate(missile.rotation);

                    // Missile shape
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(-15, -5, 30, 10);
                    ctx.beginPath();
                    ctx.moveTo(15, 0);
                    ctx.lineTo(20, -5);
                    ctx.lineTo(20, 5);
                    ctx.closePath();
                    ctx.fill();

                    // Fins
                    ctx.fillStyle = '#00aa00';
                    ctx.fillRect(-12, -8, 8, 3);
                    ctx.fillRect(-12, 5, 8, 3);

                    ctx.restore();
                });
            }
        }

        // 🤖 SUPPORT DRONE - Spawn 4 drones that orbit and shoot the boss
        class SupportDrone {
            constructor(game) {
                this.game = game;
                this.drones = [];
                this.duration = 8000; // 8 seconds
                this.timer = 0;
                this.remove = false;
                this.shootInterval = 800; // Shoot every 0.8 seconds

                // Spawn 4 drones around the boss
                for (let i = 0; i < 4; i++) {
                    const angle = (Math.PI * 2 / 4) * i;
                    this.drones.push({
                        angle: angle,
                        distance: 120,
                        shootTimer: Math.random() * this.shootInterval,
                        rotation: 0
                    });
                }
            }

            update(deltaTime) {
                this.timer += deltaTime;

                if (this.timer >= this.duration) {
                    this.remove = true;
                    return;
                }

                if (!this.game.boss || this.game.boss.remove) {
                    this.remove = true;
                    return;
                }

                this.drones.forEach(drone => {
                    // Orbit around boss
                    drone.angle += deltaTime * 0.002;
                    drone.rotation += deltaTime * 0.003;

                    // Shoot at boss
                    drone.shootTimer += deltaTime;
                    if (drone.shootTimer >= this.shootInterval) {
                        drone.shootTimer = 0;
                        this.shootAtBoss(drone);
                    }
                });
            }

            shootAtBoss(drone) {
                const droneX = this.game.boss.x + Math.cos(drone.angle) * drone.distance;
                const droneY = this.game.boss.y + Math.sin(drone.angle) * drone.distance;

                const damage = 150;
                this.game.boss.hp -= damage;

                // Create laser beam effect
                this.game.particles.push({
                    type: 'laser',
                    x1: droneX,
                    y1: droneY,
                    x2: this.game.boss.x,
                    y2: this.game.boss.y,
                    life: 0.3,
                    color: '#ffff00'
                });

                // Damage number
                this.game.createFloatingText(
                    this.game.boss.x,
                    this.game.boss.y,
                    `-${damage}`,
                    '#ffff00',
                    24
                );
            }

            draw(ctx) {
                if (!this.game.boss || this.game.boss.remove) return;

                this.drones.forEach(drone => {
                    const x = this.game.boss.x + Math.cos(drone.angle) * drone.distance;
                    const y = this.game.boss.y + Math.sin(drone.angle) * drone.distance;

                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(drone.rotation);

                    // Drone body
                    ctx.fillStyle = '#ffff00';
                    ctx.fillRect(-12, -12, 24, 24);

                    // Propellers
                    ctx.strokeStyle = '#ffaa00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-15, -15);
                    ctx.lineTo(-8, -8);
                    ctx.moveTo(15, -15);
                    ctx.lineTo(8, -8);
                    ctx.moveTo(-15, 15);
                    ctx.lineTo(-8, 8);
                    ctx.moveTo(15, 15);
                    ctx.lineTo(8, 8);
                    ctx.stroke();

                    // Center eye
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(-3, -3, 6, 6);

                    ctx.restore();
                });
            }
        }

        // ⚡ ELECTRIC SHOCK - Chain lightning that bounces between enemies
        class ElectricShock {
            constructor(game) {
                this.game = game;
                this.duration = 3000; // 3 seconds
                this.timer = 0;
                this.remove = false;
                this.shockInterval = 300; // Shock every 0.3 seconds
                this.shockTimer = 0;
                this.lightningBolts = [];
            }

            update(deltaTime) {
                this.timer += deltaTime;
                this.shockTimer += deltaTime;

                if (this.timer >= this.duration) {
                    this.remove = true;
                    return;
                }

                // Trigger shock wave
                if (this.shockTimer >= this.shockInterval) {
                    this.shockTimer = 0;
                    this.triggerShock();
                }

                // Update lightning bolts
                this.lightningBolts.forEach(bolt => {
                    bolt.life -= deltaTime / 200;
                });
                this.lightningBolts = this.lightningBolts.filter(b => b.life > 0);
            }

            triggerShock() {
                // Damage boss
                if (this.game.boss && !this.game.boss.remove) {
                    const bossDamage = 200;
                    this.game.boss.hp -= bossDamage;

                    this.game.createFloatingText(
                        this.game.boss.x,
                        this.game.boss.y,
                        `-${bossDamage}`,
                        '#ffff00',
                        32
                    );

                    // Create lightning from boss to minions
                    this.game.enemies.forEach(enemy => {
                        if (!enemy.isBoss && !enemy.remove) {
                            const minionDamage = 100;
                            enemy.hp -= minionDamage;

                            // Create lightning bolt
                            this.lightningBolts.push({
                                x1: this.game.boss.x,
                                y1: this.game.boss.y,
                                x2: enemy.x,
                                y2: enemy.y,
                                life: 1.0,
                                segments: this.generateLightningSegments(
                                    this.game.boss.x,
                                    this.game.boss.y,
                                    enemy.x,
                                    enemy.y
                                )
                            });
                        }
                    });
                }
            }

            generateLightningSegments(x1, y1, x2, y2) {
                const segments = [];
                const numSegments = 8;
                const dx = (x2 - x1) / numSegments;
                const dy = (y2 - y1) / numSegments;

                segments.push({ x: x1, y: y1 });

                for (let i = 1; i < numSegments; i++) {
                    const x = x1 + dx * i + (Math.random() - 0.5) * 30;
                    const y = y1 + dy * i + (Math.random() - 0.5) * 30;
                    segments.push({ x, y });
                }

                segments.push({ x: x2, y: y2 });
                return segments;
            }

            draw(ctx) {
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 3;
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = 10;

                this.lightningBolts.forEach(bolt => {
                    ctx.globalAlpha = bolt.life;
                    ctx.beginPath();
                    bolt.segments.forEach((seg, index) => {
                        if (index === 0) {
                            ctx.moveTo(seg.x, seg.y);
                        } else {
                            ctx.lineTo(seg.x, seg.y);
                        }
                    });
                    ctx.stroke();
                });

                ctx.globalAlpha = 1.0;
                ctx.shadowBlur = 0;
            }
        }

        // ☢️ ATOMIC BOMB - Ultimate weapon dealing massive damage
        class AtomicBomb {
            constructor(targetX, targetY, boss, game) {
                this.game = game;
                this.boss = boss;
                this.targetX = targetX;
                this.targetY = targetY;
                this.phase = 'WARNING'; // WARNING → EXPLOSION → MUSHROOM → DONE
                this.timer = 0;
                this.remove = false;
                this.explosionRadius = 0;
                this.maxExplosionRadius = 400;
                this.mushroomHeight = 0;
                this.maxMushroomHeight = 300;
                this.particles = [];
                this.damageDealt = false;
                this.shockwaveRadius = 0;
                this.flashIntensity = 0;
            }

            update(deltaTime) {
                this.timer += deltaTime;

                switch(this.phase) {
                    case 'WARNING':
                        if (this.timer >= 1000) {
                            this.phase = 'EXPLOSION';
                            this.timer = 0;
                            this.explode();
                        }
                        break;

                    case 'EXPLOSION':
                        // Expand explosion radius
                        this.explosionRadius = Math.min(
                            this.maxExplosionRadius,
                            this.explosionRadius + (deltaTime * 0.8)
                        );
                        this.shockwaveRadius = this.explosionRadius * 1.2;

                        // Flash effect
                        this.flashIntensity = Math.max(0, 1 - (this.timer / 500));

                        // Screen shake
                        if (this.timer < 500) {
                            const intensity = 50 * (1 - this.timer / 500);
                            this.game.screenShake.x = (Math.random() - 0.5) * intensity;
                            this.game.screenShake.y = (Math.random() - 0.5) * intensity;
                        }

                        // Update particles
                        this.particles.forEach(p => {
                            p.x += p.vx * (deltaTime / 16);
                            p.y += p.vy * (deltaTime / 16);
                            p.life -= deltaTime / 1000;
                            p.radius *= 0.98;
                        });
                        this.particles = this.particles.filter(p => p.life > 0);

                        if (this.timer >= 800) {
                            this.phase = 'MUSHROOM';
                            this.timer = 0;
                        }
                        break;

                    case 'MUSHROOM':
                        // Grow mushroom cloud
                        this.mushroomHeight = Math.min(
                            this.maxMushroomHeight,
                            this.mushroomHeight + (deltaTime * 0.3)
                        );

                        // Fade explosion
                        this.explosionRadius *= 0.95;

                        if (this.timer >= 2000) {
                            this.phase = 'DONE';
                            this.remove = true;
                            // Restore normal game speed
                            if (this.game.timeScale) {
                                this.game.timeScale = 1.0;
                            }
                        }
                        break;
                }
            }

            explode() {
                // Deal damage to boss (33% of max HP)
                if (this.boss && this.boss.hp > 0 && !this.damageDealt) {
                    const damage = Math.floor(this.boss.maxHp * 0.33);
                    this.boss.hp = Math.max(0, this.boss.hp - damage);
                    this.damageDealt = true;

                    // Show damage text
                    this.game.createFloatingText(
                        this.targetX,
                        this.targetY - 100,
                        `☢️ -${damage} ☢️`,
                        '#ff00ff',
                        60
                    );
                }

                // Create explosion particles
                for (let i = 0; i < 100; i++) {
                    const angle = (Math.PI * 2 / 100) * i;
                    const speed = 3 + Math.random() * 5;
                    this.particles.push({
                        x: this.targetX,
                        y: this.targetY,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        radius: 10 + Math.random() * 20,
                        life: 1 + Math.random() * 2,
                        color: Math.random() > 0.5 ? '#ff6600' : '#ffaa00'
                    });
                }

                // Slow motion effect
                if (this.game.timeScale !== undefined) {
                    this.game.timeScale = 0.15;
                }

                // Play sound effect
                this.game.audio.playExplosion();
            }

            render(ctx) {
                ctx.save();

                // WARNING phase - pulsing target indicator
                if (this.phase === 'WARNING') {
                    const pulse = Math.sin(this.timer / 100) * 0.3 + 0.7;
                    const radius = 60 * pulse;

                    // Warning circle
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 4;
                    ctx.setLineDash([10, 10]);
                    ctx.beginPath();
                    ctx.arc(this.targetX, this.targetY, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Crosshair
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(this.targetX - 40, this.targetY);
                    ctx.lineTo(this.targetX + 40, this.targetY);
                    ctx.moveTo(this.targetX, this.targetY - 40);
                    ctx.lineTo(this.targetX, this.targetY + 40);
                    ctx.stroke();

                    // Warning text
                    ctx.fillStyle = '#ff0000';
                    ctx.font = 'bold 24px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText('☢️ INCOMING ☢️', this.targetX, this.targetY - 80);
                }

                // EXPLOSION phase
                if (this.phase === 'EXPLOSION') {
                    // Flash effect
                    if (this.flashIntensity > 0) {
                        ctx.fillStyle = `rgba(255, 255, 255, ${this.flashIntensity * 0.6})`;
                        ctx.fillRect(0, 0, this.game.width, this.game.height);
                    }

                    // Main explosion
                    const gradient = ctx.createRadialGradient(
                        this.targetX, this.targetY, 0,
                        this.targetX, this.targetY, this.explosionRadius
                    );
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                    gradient.addColorStop(0.3, 'rgba(255, 200, 0, 0.7)');
                    gradient.addColorStop(0.6, 'rgba(255, 100, 0, 0.4)');
                    gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(this.targetX, this.targetY, this.explosionRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // Shockwave ring
                    ctx.strokeStyle = `rgba(255, 255, 255, ${1 - (this.timer / 800)})`;
                    ctx.lineWidth = 8;
                    ctx.beginPath();
                    ctx.arc(this.targetX, this.targetY, this.shockwaveRadius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Particles
                    this.particles.forEach(p => {
                        ctx.fillStyle = p.color;
                        ctx.globalAlpha = p.life / 2;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    ctx.globalAlpha = 1;
                }

                // MUSHROOM phase
                if (this.phase === 'MUSHROOM') {
                    // Fading explosion base
                    if (this.explosionRadius > 10) {
                        const baseGradient = ctx.createRadialGradient(
                            this.targetX, this.targetY, 0,
                            this.targetX, this.targetY, this.explosionRadius
                        );
                        baseGradient.addColorStop(0, 'rgba(255, 100, 0, 0.3)');
                        baseGradient.addColorStop(1, 'rgba(255, 0, 0, 0)');

                        ctx.fillStyle = baseGradient;
                        ctx.beginPath();
                        ctx.arc(this.targetX, this.targetY, this.explosionRadius, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Mushroom cloud stem
                    const stemGradient = ctx.createLinearGradient(
                        this.targetX, this.targetY,
                        this.targetX, this.targetY - this.mushroomHeight
                    );
                    stemGradient.addColorStop(0, 'rgba(100, 100, 100, 0.8)');
                    stemGradient.addColorStop(1, 'rgba(150, 150, 150, 0.6)');

                    ctx.fillStyle = stemGradient;
                    ctx.fillRect(
                        this.targetX - 30,
                        this.targetY - this.mushroomHeight,
                        60,
                        this.mushroomHeight
                    );

                    // Mushroom cloud cap
                    if (this.mushroomHeight > 50) {
                        const capY = this.targetY - this.mushroomHeight;
                        const capRadius = 80;

                        const capGradient = ctx.createRadialGradient(
                            this.targetX, capY, 0,
                            this.targetX, capY, capRadius
                        );
                        capGradient.addColorStop(0, 'rgba(200, 200, 200, 0.9)');
                        capGradient.addColorStop(0.7, 'rgba(100, 100, 100, 0.7)');
                        capGradient.addColorStop(1, 'rgba(80, 80, 80, 0.3)');

                        ctx.fillStyle = capGradient;
                        ctx.beginPath();
                        ctx.arc(this.targetX, capY, capRadius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                ctx.restore();
            }
        }

        // 🔋 Weapon Charge System - Manages unlocking and charging weapons
        class WeaponChargeSystem {
            constructor(game) {
                this.game = game;
                this.charges = {
                    stink: 0,
                    freeze: 0,
                    drone: 0,
                    shock: 0,
                    bomb: 0
                };
                this.maxCharges = {
                    stink: 3,
                    freeze: 2,
                    drone: 2,
                    shock: 2,
                    bomb: 1
                };
                this.cooldowns = {
                    stink: 0,
                    freeze: 0,
                    drone: 0,
                    shock: 0,
                    bomb: 0
                };
                this.cooldownDurations = {
                    stink: 30000,
                    freeze: 45000,
                    drone: 40000,
                    shock: 35000,
                    bomb: Infinity // One use per boss
                };
                this.lastComboCheck = 0;
            }

            update(deltaTime) {
                // Update cooldowns
                Object.keys(this.cooldowns).forEach(weapon => {
                    if (this.cooldowns[weapon] > 0) {
                        this.cooldowns[weapon] -= deltaTime;
                        if (this.cooldowns[weapon] < 0) this.cooldowns[weapon] = 0;
                    }
                });
            }

            checkComboMilestones(combo) {
                // Prevent duplicate charges for same combo
                if (combo === this.lastComboCheck) return;
                this.lastComboCheck = combo;

                // Award charges based on combo milestones
                if (combo >= 5 && this.charges.stink < this.maxCharges.stink) {
                    this.addCharge('stink');
                }
                if (combo >= 8 && this.charges.freeze < this.maxCharges.freeze) {
                    this.addCharge('freeze');
                }
                if (combo >= 10 && this.charges.drone < this.maxCharges.drone) {
                    this.addCharge('drone');
                }
                if (combo >= 12 && this.charges.shock < this.maxCharges.shock) {
                    this.addCharge('shock');
                }
                if (combo >= 20 && this.charges.bomb < this.maxCharges.bomb) {
                    this.addCharge('bomb');
                }
            }

            addCharge(weaponId) {
                this.charges[weaponId]++;
                const names = {
                    stink: 'STINK MISSILE',
                    freeze: 'FREEZING TORNADO',
                    drone: 'SHOOTING DRONES',
                    shock: 'ELECTRIC SHOCK',
                    bomb: 'ATOMIC BOMB'
                };
                this.game.createFloatingText(
                    this.game.width / 2,
                    100,
                    `${names[weaponId]} CHARGED! ⚡`,
                    '#ffd700'
                );
                this.game.audio.playUpgrade(); // Use existing sound
            }

            canUseWeapon(weaponId) {
                return this.charges[weaponId] > 0 && this.cooldowns[weaponId] <= 0;
            }

            useCharge(weaponId) {
                if (this.canUseWeapon(weaponId)) {
                    this.charges[weaponId]--;
                    this.cooldowns[weaponId] = this.cooldownDurations[weaponId];
                    return true;
                }
                return false;
            }

            reset() {
                // Reset all charges (called when starting new level)
                Object.keys(this.charges).forEach(weapon => {
                    this.charges[weapon] = 0;
                });
                this.lastComboCheck = 0;
            }

            resetCooldowns() {
                // Reset cooldowns when boss defeated
                Object.keys(this.cooldowns).forEach(weapon => {
                    if (weapon !== 'bomb') { // Bomb stays on cooldown
                        this.cooldowns[weapon] = 0;
                    }
                });
            }
        }


        // 🎨 Radial Weapon Wheel UI
        class RadialWeaponWheel {
            constructor(game) {
                this.game = game;
                this.visible = false;
                this.weapons = [
                    { angle: 0, id: 'freeze', icon: '❄️', name: 'FREEZE' },
                    { angle: Math.PI / 2, id: 'drone', icon: '🤖', name: 'DRONES' },
                    { angle: Math.PI, id: 'stink', icon: '💣', name: 'STINK' },
                    { angle: Math.PI * 1.5, id: 'shock', icon: '⚡', name: 'SHOCK' },
                ];
                this.centerWeapon = { id: 'bomb', icon: '☢️', name: 'ATOMIC BOMB' };
                this.selectedWeapon = null;
                this.wheelRadius = 30; // 🔧 v0.1.2: 50% smaller (was 60px)
                this.centerX = 0;
                this.centerY = 0;
                this.pulse = 0;
            }

            show() {
                this.visible = true;
                // 🔧 v0.1.2: Position in LOWER-RIGHT corner for better UX
                // Position: 90px from right, 120px from bottom (above HP bar)
                this.centerX = this.game.width - 90;
                this.centerY = this.game.height - 120;
            }

            hide() {
                this.visible = false;
                this.selectedWeapon = null;
            }

            update(deltaTime) {
                if (!this.visible) return;
                this.pulse += deltaTime / 1000;
            }

            selectWeapon(id) {
                const weapon = [...this.weapons, this.centerWeapon].find(w => w.id === id);
                if (weapon && this.game.weaponCharges.canUseWeapon(id)) {
                    this.game.activateWeapon(id);
                    // 🔧 FIXED: Don't hide wheel - keep it visible during boss battle
                }
            }

            render(ctx) {
                if (!this.visible) return;

                ctx.save();

                // 🔧 FIXED: No full-screen overlay - keep game visible like mobile games

                // Background circle - semi-transparent
                ctx.fillStyle = 'rgba(20, 20, 20, 0.7)';
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.8)';
                ctx.lineWidth = 2;
                ctx.shadowBlur = 15;
                ctx.shadowColor = 'rgba(255, 215, 0, 0.5)';
                ctx.beginPath();
                // 🔧 v0.1.2: 50% smaller background (+18px instead of +35px)
                ctx.arc(this.centerX, this.centerY, this.wheelRadius + 18, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                ctx.shadowBlur = 0;

                // 🔧 v0.1.2: Compact title above wheel
                ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
                ctx.font = 'bold 10px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('WEAPONS', this.centerX, this.centerY - this.wheelRadius - 20);

                // Render outer weapons
                this.weapons.forEach((weapon, index) => {
                    this.renderWeapon(ctx, weapon, index + 1);
                });

                // Render center weapon (Atomic Bomb)
                this.renderCenterWeapon(ctx);

                ctx.restore();
            }

            renderWeapon(ctx, weapon, keyNumber) {
                const x = this.centerX + Math.cos(weapon.angle) * this.wheelRadius;
                const y = this.centerY + Math.sin(weapon.angle) * this.wheelRadius;

                const charges = this.game.weaponCharges.charges[weapon.id];
                const cooldown = this.game.weaponCharges.cooldowns[weapon.id];
                const canUse = this.game.weaponCharges.canUseWeapon(weapon.id);

                // Weapon circle background - semi-transparent
                ctx.fillStyle = canUse ? 'rgba(50, 50, 50, 0.8)' : 'rgba(20, 20, 20, 0.7)';
                ctx.strokeStyle = canUse ? 'rgba(0, 255, 0, 0.9)' : 'rgba(85, 85, 85, 0.7)';
                ctx.lineWidth = canUse ? 3 : 2;

                if (canUse) {
                    const pulseSize = Math.sin(this.pulse * 3) * 2;
                    ctx.shadowBlur = 15 + pulseSize;
                    ctx.shadowColor = 'rgba(0, 255, 0, 0.6)';
                }

                ctx.beginPath();
                // 🔧 v0.1.2: 50% smaller circles (15px instead of 30px)
                ctx.arc(x, y, 15, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                ctx.shadowBlur = 0;

                // Cooldown overlay
                if (cooldown > 0) {
                    const totalCooldown = this.game.weaponCharges.cooldownDurations[weapon.id];
                    const percentage = cooldown / totalCooldown;

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.arc(x, y, 15, -Math.PI / 2, -Math.PI / 2 + (Math.PI * 2 * percentage));
                    ctx.lineTo(x, y);
                    ctx.closePath();
                    ctx.fill();

                    // Cooldown text
                    ctx.fillStyle = '#ff0000';
                    ctx.font = 'bold 10px Courier New';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(Math.ceil(cooldown / 1000) + 's', x, y);
                } else {
                    // Weapon icon
                    ctx.font = 'bold 18px Arial'; // 🔧 v0.1.2: Smaller icon (18px instead of 24px)
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = canUse ? '#fff' : '#555';
                    ctx.fillText(weapon.icon, x, y);
                }

                // Charge count
                if (charges > 0) {
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
                    ctx.font = 'bold 8px Courier New';
                    ctx.fillText(`×${charges}`, x + 12, y - 12);
                }

                // Key number - smaller for compact UI
                ctx.fillStyle = 'rgba(136, 136, 136, 0.8)';
                ctx.font = 'bold 8px Courier New';
                ctx.fillText(keyNumber.toString(), x, y + 20);

                // Weapon name - removed to save space
            }

            renderCenterWeapon(ctx) {
                const x = this.centerX;
                const y = this.centerY;
                const weapon = this.centerWeapon;

                const charges = this.game.weaponCharges.charges[weapon.id];
                const canUse = this.game.weaponCharges.canUseWeapon(weapon.id);

                // Larger center weapon - semi-transparent
                ctx.fillStyle = canUse ? 'rgba(139, 0, 0, 0.8)' : 'rgba(20, 20, 20, 0.7)';
                ctx.strokeStyle = canUse ? 'rgba(255, 0, 0, 0.9)' : 'rgba(85, 85, 85, 0.7)';
                ctx.lineWidth = canUse ? 3 : 2;

                if (canUse) {
                    const pulseSize = Math.sin(this.pulse * 5) * 3;
                    ctx.shadowBlur = 20 + pulseSize;
                    ctx.shadowColor = 'rgba(255, 0, 0, 0.6)';
                }

                ctx.beginPath();
                // 🔧 v0.1.2: 50% smaller center (19px instead of 38px)
                ctx.arc(x, y, 19, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                ctx.shadowBlur = 0;

                // Icon
                ctx.font = 'bold 22px Arial'; // 🔧 v0.1.2: Smaller icon (22px instead of 30px)
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = canUse ? '#fff' : '#555';
                ctx.fillText(weapon.icon, x, y);

                // Charge indicator or requirement
                if (charges > 0) {
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
                    ctx.font = 'bold 7px Courier New';
                    ctx.fillText('READY!', x, y + 26);
                } else {
                    ctx.fillStyle = 'rgba(136, 136, 136, 0.8)';
                    ctx.font = 'bold 7px Courier New';
                    ctx.fillText('20 COMBO', x, y + 26);
                }

                // Key number
                ctx.fillStyle = 'rgba(136, 136, 136, 0.8)';
                ctx.font = 'bold 8px Courier New';
                ctx.fillText('5', x, y - 26);
            }

            // Check if mouse/touch is over a weapon
            getWeaponAtPosition(x, y) {
                // Check outer weapons
                for (let weapon of this.weapons) {
                    const wx = this.centerX + Math.cos(weapon.angle) * this.wheelRadius;
                    const wy = this.centerY + Math.sin(weapon.angle) * this.wheelRadius;
                    const dist = Math.hypot(x - wx, y - wy);
                    if (dist < 24) return weapon.id; // 🔧 v0.1.3: Increased to 24px for better mobile touch (48x48px target)
                }

                // Check center weapon
                const distCenter = Math.hypot(x - this.centerX, y - this.centerY);
                if (distCenter < 30) return this.centerWeapon.id; // 🔧 v0.1.3: Increased to 30px for better mobile touch (60x60px target)

                return null;
            }
        }


        const game = new Game();
    </script>
</body>
</html>